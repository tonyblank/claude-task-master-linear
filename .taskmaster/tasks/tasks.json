{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Linear SDK and API Integration",
        "description": "Install and configure the Linear SDK (@linear/sdk) in the Taskmaster project, verify API connectivity with a test Linear workspace",
        "details": "Install @linear/sdk version ^16.0.0 or latest stable. Create a test Linear API key from Linear settings (Settings > API > Personal API keys). Set up a sandbox Linear team for development testing. Implement a simple test script to verify GraphQL connectivity by querying the current user (linearClient.viewer). Store test credentials securely in .env file (LINEAR_API_KEY). Ensure the SDK can be imported and basic queries work. This forms the foundation for all Linear API interactions.",
        "testStrategy": "Create unit test that mocks Linear SDK responses. Integration test with real Linear sandbox to verify: 1) API key authentication works, 2) Can query user info, 3) Can list teams, 4) Handle invalid API key gracefully with proper error messages",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Configuration Schema and Environment Loading",
        "description": "Define and implement the configuration structure for Linear integration settings in Taskmaster's config.json and secure API key loading from .env",
        "details": "Extend Taskmaster's config.json schema to include a 'linear' section with fields: teamId, projectId, autoSync, stateMapping, useTaskmasterLabel, useLanguageLabels, useCategoryLabels. Implement config reading/writing utilities that preserve existing config while adding Linear section. Ensure dotenv is properly configured to load LINEAR_API_KEY from .env file. Add .env to .gitignore if not already present. Create helper functions: getLinearConfig(), updateLinearConfig(), isLinearConfigured(). Implement validation to ensure required fields are present before attempting sync operations.",
        "testStrategy": "Unit tests for config manipulation functions ensuring they don't corrupt existing config. Test environment variable loading with mock .env files. Test config validation with various incomplete configurations. Verify .env is not committed to version control",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Linear configuration schema structure",
            "description": "Create a comprehensive schema design for the Linear configuration system that supports all required features while maintaining flexibility for future extensions.",
            "dependencies": [],
            "details": "Define JSON schema for configuration including types, required fields, and nested structures. Document the schema with examples and edge cases. Consider performance implications of schema design. Include support for environment-specific configurations.",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Implement config.json extension with backward compatibility",
            "description": "Extend the existing config.json format to support new features while ensuring backward compatibility with existing configurations.",
            "dependencies": [
              1
            ],
            "details": "Create migration utilities for old config formats. Implement version detection and automatic upgrading. Document breaking changes and provide migration guides. Test with various legacy configurations to ensure compatibility.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Create dotenv integration for secure credential loading",
            "description": "Implement a secure system to load sensitive credentials from environment variables using dotenv.",
            "dependencies": [
              1,
              2
            ],
            "details": "Set up dotenv package integration. Create a secure credential loading mechanism. Implement fallback strategies for missing environment variables. Document security best practices for credential management.",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Build configuration validation utilities",
            "description": "Develop robust validation utilities to ensure configuration integrity and provide helpful error messages.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement schema validation using JSON Schema or similar. Create custom validators for complex business rules. Design clear, actionable error messages. Add warning system for deprecated or suboptimal configurations.",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Implement config getter/setter helper functions",
            "description": "Create a set of helper functions to safely get and set configuration values with type safety and validation.",
            "dependencies": [
              1,
              2,
              4
            ],
            "details": "Develop type-safe getter functions with default values. Implement setter functions with validation. Add support for path-based access (e.g., 'database.credentials.username'). Create utilities for bulk updates and configuration merging.",
            "status": "done"
          },
          {
            "id": 6,
            "title": "Write comprehensive tests for config manipulation",
            "description": "Create a thorough test suite covering all aspects of the configuration system to ensure reliability.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Write unit tests for all configuration components. Create integration tests for the full configuration system. Implement performance tests for large configurations. Add security tests for credential handling. Create documentation with test coverage reports.",
            "status": "done"
          }
        ]
      },
      {
        "id": 3,
        "title": "Create Integration Manager and Event Hook System",
        "description": "Build the event-driven integration manager that will connect Taskmaster's core operations to the Linear integration module",
        "details": "Create IntegrationManager class with methods: emit(eventName, data), register(integration), isEnabled(). Define standard events: taskCreated, taskUpdated, taskStatusChanged, taskRemoved, subtaskAdded, tasksBulkCreated. Implement async event handling with proper error boundaries. For MVP, start with direct Linear integration calls, but structure code to easily refactor to plugin architecture. Add integration points to one command (addTask) as proof of concept. Ensure events are emitted after local operations succeed but before command completion for proper error handling and user feedback.",
        "testStrategy": "Unit tests for IntegrationManager with mock integrations. Test event emission and handling with various payloads. Test error isolation - ensure one integration failure doesn't affect others. Verify async handling doesn't block CLI operations",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design event-driven architecture",
            "description": "Create a comprehensive design document for the event-driven architecture, including event types, flow diagrams, and component interactions.",
            "dependencies": [],
            "details": "Define all possible event types (task creation, updates, deletions, etc.), create flow diagrams showing how events propagate through the system, document component responsibilities, and establish patterns for event consumption. Include considerations for async vs sync processing and scalability.",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Implement IntegrationManager base class",
            "description": "Create the foundational IntegrationManager class that will serve as the base for all integration implementations.",
            "dependencies": [
              1
            ],
            "details": "Implement a base class with core functionality including initialization, configuration management, lifecycle hooks, and integration with the event system. Define required interfaces and abstract methods that specific integrations must implement.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Create event emission system",
            "description": "Build the system responsible for emitting events and handling them asynchronously.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement event emitters, event bus, and subscription mechanisms. Ensure proper async handling with queuing capabilities. Include retry logic and delivery guarantees where appropriate. Design for performance under high event volume.",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Build error boundary and isolation mechanisms",
            "description": "Implement robust error handling to ensure failures in one integration don't affect others or the core application.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create error boundaries around integration execution, implement isolation patterns, add logging and monitoring hooks, and design recovery mechanisms. Include circuit breaker patterns to prevent cascading failures.",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Implement integration registration system",
            "description": "Create a system for dynamically registering and managing integrations at runtime.",
            "dependencies": [
              2
            ],
            "details": "Build a registry for integrations, implement activation/deactivation mechanisms, create configuration validation, and add discovery capabilities. Include versioning support and dependency management between integrations.",
            "status": "done"
          },
          {
            "id": 6,
            "title": "Add hooks to addTask command as POC",
            "description": "Implement event hooks in the addTask command as a proof of concept for the integration system.",
            "dependencies": [
              3,
              5
            ],
            "details": "Modify the addTask command to emit appropriate events, create sample integrations that respond to these events, and demonstrate the full event flow. Document the implementation as a reference for other commands.",
            "status": "done"
          },
          {
            "id": 7,
            "title": "Create event payload standardization",
            "description": "Define and implement standardized formats for event payloads to ensure consistency across the system.",
            "dependencies": [
              1,
              3
            ],
            "details": "Create schemas for different event types, implement serialization/deserialization, add validation mechanisms, and ensure backward compatibility. Include documentation for payload formats and versioning strategy.",
            "status": "done"
          },
          {
            "id": 8,
            "title": "Write comprehensive test suite",
            "description": "Develop a thorough test suite covering all aspects of the event system and integration framework.",
            "dependencies": [
              4,
              6,
              7
            ],
            "details": "Create unit tests for individual components, integration tests for event flows, performance tests for high-volume scenarios, and failure mode tests. Include mocking utilities for testing integrations in isolation.",
            "status": "done"
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Linear Issue Creation with ID Storage",
        "description": "Build core functionality to create Linear issues from Taskmaster tasks and store the Linear issue ID back in tasks.json",
        "details": "Create LinearIntegration module with onTaskCreated handler. Implement createIssue call using Linear SDK with proper field mapping: title, description (combining description + details + testStrategy with Markdown formatting), teamId, projectId (if configured). Parse response to extract issue.id, issue.identifier, issue.branchName. Implement atomic file update to add linearIssueId, linearIssueNumber, and branchName to task in tasks.json. Handle network failures gracefully without corrupting local data. Format success message showing Linear issue number. Implement retry logic for transient failures.",
        "testStrategy": "Mock Linear SDK responses for unit tests. Integration test creating real Linear issue in sandbox. Test file update atomicity - ensure no data loss if update fails. Test with various task content including special characters, long descriptions. Verify idempotency - no duplicate issues on retry",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create LinearIntegration module structure",
            "description": "Set up the base module structure for Linear integration including class definition, initialization, and configuration handling",
            "dependencies": [],
            "details": "Create LinearIntegration class with constructor accepting API key and workspace ID. Set up proper module exports, type definitions for Linear API responses, and basic configuration validation. Include placeholder methods for all planned functionality.",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Implement issue creation with field mapping logic",
            "description": "Build the core functionality to create Linear issues with proper field mapping from task data",
            "dependencies": [
              1
            ],
            "details": "Implement createIssue method that maps task properties (title, description, priority, labels) to Linear's API format. Handle team/project assignment, priority levels, and label creation/assignment. Include proper request headers and authentication.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Build response parsing and ID extraction",
            "description": "Create robust response parsing logic to extract Linear issue IDs and handle various response formats",
            "dependencies": [
              2
            ],
            "details": "Parse Linear API responses to extract issue IDs, URLs, and other metadata. Handle both successful responses and error cases. Create standardized response objects that include issue ID, URL, and any relevant metadata for storage.",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Implement atomic file update mechanism",
            "description": "Build a safe file update system that ensures atomic writes when storing Linear issue IDs",
            "dependencies": [
              3
            ],
            "details": "Implement file locking or temporary file approach for atomic updates. Read existing file content, update with new Linear ID mapping, and write back atomically. Handle concurrent access scenarios and ensure data integrity during crashes.",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Add retry logic with exponential backoff",
            "description": "Implement intelligent retry mechanism for API calls with exponential backoff strategy",
            "dependencies": [
              2,
              3
            ],
            "details": "Create retry wrapper for Linear API calls with configurable max attempts and backoff multiplier. Handle rate limiting (429 status), network errors, and temporary failures. Include jitter to prevent thundering herd problem.",
            "status": "done"
          },
          {
            "id": 6,
            "title": "Create formatted success/error messaging",
            "description": "Build comprehensive messaging system for user feedback on operations",
            "dependencies": [
              3,
              5
            ],
            "details": "Design consistent message formats for success cases (with Linear issue URL), various error types (auth, network, validation), and retry attempts. Include contextual information and actionable error messages for debugging.",
            "status": "done"
          },
          {
            "id": 7,
            "title": "Write unit and integration tests",
            "description": "Create comprehensive test suite covering all functionality including mocked API calls and file operations",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Write unit tests for field mapping, response parsing, and retry logic. Create integration tests with mocked Linear API. Test atomic file updates with simulated failures. Include edge cases like malformed responses and concurrent updates.",
            "status": "done"
          }
        ]
      },
      {
        "id": 5,
        "title": "Build Interactive Setup Wizard Command",
        "description": "Create the 'sync-setup' command that guides users through Linear integration configuration with interactive prompts",
        "details": "Implement interactive CLI wizard using inquirer or similar library. Prompt sequence: 1) Linear API key (hidden input), 2) Validate key by fetching user info, 3) List available teams and let user select, 4) Optional project selection within team, 5) Label preferences (Y/N for Taskmaster label, language labels, category labels), 6) Primary language selection if language labels enabled. Store teamId and preferences in config.json, API key in .env. Implement proper error handling for invalid API keys or network issues. Add success confirmation and next steps guidance.",
        "testStrategy": "Mock user inputs and Linear API responses for unit tests. Test validation of API key with invalid/expired keys. Test team selection with various team configurations. Verify config file is created/updated correctly. Test .env file creation and permissions",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up inquirer for interactive prompts",
            "description": "Install and configure the inquirer package to handle interactive command-line prompts throughout the setup process",
            "dependencies": [],
            "details": "Install inquirer as a dependency, create a base prompt utility module that can be reused across different setup steps, and establish consistent styling and validation patterns for all prompts",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Implement API key validation flow",
            "description": "Create an interactive prompt to collect and validate the Linear API key from the user",
            "dependencies": [
              1
            ],
            "details": "Prompt user for API key input with secure masking, validate the key format, test the key by making a simple API call to Linear, provide clear error messages for invalid keys, and allow retry on failure",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Create team listing and selection interface",
            "description": "Fetch available teams from Linear API and present them as a selectable list to the user",
            "dependencies": [
              2
            ],
            "details": "Use the validated API key to fetch all teams the user has access to, display teams in a searchable list format using inquirer, handle pagination if needed, and store the selected team ID for subsequent use",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Build project selection within teams",
            "description": "Display projects within the selected team and allow user to choose one or multiple projects",
            "dependencies": [
              3
            ],
            "details": "Fetch all projects for the selected team, present them in a checkbox list allowing multiple selections, show project descriptions if available, validate that at least one project is selected, and store project IDs for configuration",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Implement label preference configuration",
            "description": "Create an interface for users to configure their label preferences and filtering options",
            "dependencies": [
              4
            ],
            "details": "Fetch existing labels from selected projects, allow users to select which labels to track, provide options for label filtering rules, configure label-based routing preferences, and validate label selections against project availability",
            "status": "done"
          },
          {
            "id": 6,
            "title": "Create config and .env file writing logic",
            "description": "Generate and write configuration files based on user selections from the setup process",
            "dependencies": [
              5
            ],
            "details": "Create .env file with API key and sensitive data, generate config.json with team, project, and label preferences, ensure proper file permissions for .env, create backup of existing files if present, and validate file write operations",
            "status": "done"
          },
          {
            "id": 7,
            "title": "Add success confirmation and help text",
            "description": "Display setup completion message with next steps and helpful information for the user",
            "dependencies": [
              6
            ],
            "details": "Show confirmation of successful setup with summary of selections, provide clear next steps for running the main application, include troubleshooting tips and links to documentation, offer option to test the configuration, and display contact information for support",
            "status": "done"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Linear Workflow State Mapping",
        "description": "Fetch Linear team's workflow states and create mapping between Taskmaster statuses and Linear state IDs (UUIDs)",
        "status": "pending",
        "dependencies": [
          1,
          5
        ],
        "priority": "high",
        "details": "Query Linear API for team's workflow states using linearClient.workflowStates({ filter: { team: { id: teamId } } }). Create direct mapping logic to match the 6 TaskMaster statuses (pending, in-progress, review, done, cancelled, deferred) to Linear state IDs (UUIDs) using sensible defaults and exact name matching. The current statusMapping in config stores state names like 'Todo', 'In Progress' but Linear API requires actual state UUIDs like 'state-uuid-123'. Implement exact name matching to resolve state names to actual Linear state IDs and store those IDs in the configuration system. Define sensible default mappings (e.g., pending → 'Todo', in-progress → 'In Progress', review → 'In Review', done → 'Done', cancelled → 'Canceled', deferred → 'Backlog'). Handle teams with custom workflows gracefully with clear error messages when mappings are missing. Implement mechanism to refresh state mappings when Linear workflows change and integrate with existing setup wizard.",
        "testStrategy": "Test with various Linear workflow configurations including custom state names. Verify correct state ID (UUID) retrieval and storage. Test fallback behavior when states don't match. Test state mapping updates when team workflow changes. Verify integration with setup wizard.",
        "subtasks": [
          {
            "id": 1,
            "title": "Query Linear API for workflow states",
            "description": "Implement API calls to fetch workflow states from Linear, including pagination handling and error management",
            "dependencies": [],
            "details": "Create a service method to query Linear's GraphQL API for workflow states. Handle authentication, pagination for large result sets, and API rate limiting. Return structured data with state IDs, names, and types.",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Implement intelligent state name matching logic",
            "description": "Build fuzzy matching algorithm to map GitHub status names to Linear workflow states",
            "dependencies": [
              1
            ],
            "details": "Create simple direct mapping between TaskMaster task statuses and Linear workflow state UUIDs. The implementation will:\n\n1) Define sensible default mappings for the 6 TaskMaster statuses to common Linear state names:\n   - pending → \"Todo\" or \"Backlog\"\n   - in-progress → \"In Progress\"\n   - review → \"In Review\"\n   - done → \"Done\" or \"Completed\"\n   - cancelled → \"Canceled\" or \"Cancelled\"\n   - deferred → \"Backlog\" or \"On Hold\"\n\n2) Implement direct name-to-UUID resolution using existing workflow state data from the Linear API. This will involve exact string matching between the default Linear state names and the actual state names in the user's Linear workspace.\n\n3) Generate complete UUID mappings for configuration storage, ensuring that each TaskMaster status is mapped to a valid Linear state UUID. This mapping will be stored in the configuration to enable direct status translation without repeated lookups.\n\n4) Use exact name matching with clear error handling for missing states. If a Linear workspace doesn't have an exact match for a default mapping, provide clear error messages to guide the user to manually configure the mapping in settings.",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Build custom mapping override system",
            "description": "Create configuration system allowing users to define custom TaskMaster-to-Linear state mappings",
            "dependencies": [
              2
            ],
            "details": "Enhance the TaskMaster configuration system to store direct TaskMaster-to-Linear state mappings using Linear state UUIDs. Modify the integrations.linear.labels.statusMapping structure to support simple UUID-based references while maintaining backward compatibility with state names. Implement validation to ensure mapped state names exist in the user's Linear workspace and that UUIDs are properly formatted. Create a utility function that allows users to easily update state name mappings in the configuration and automatically regenerate the corresponding UUIDs. Add clear documentation explaining the simplified mapping approach and how to configure it correctly. Include a migration path for users transitioning from previous configuration formats.\n<info added on 2025-06-26T22:47:43.043Z>\nThe custom mapping override system will build directly on the intelligent state name matching logic from task 6.2, which is now complete. This approach eliminates the need for a separate caching mechanism as originally planned. The state mapping implementation should focus on efficient UUID lookups while maintaining the ability to fall back to name-based matching when needed. This simplification will reduce complexity and potential points of failure in the integration flow.\n</info added on 2025-06-26T22:47:43.043Z>",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Handle edge cases for custom workflows",
            "description": "Implement fallback mechanisms and error handling for non-standard workflow configurations",
            "dependencies": [
              2,
              4
            ],
            "details": "Add logic to handle missing states, circular dependencies, archived workflows, and team-specific configurations. Implement sensible defaults and user notifications for unmapped states. Provide clear error messages when exact matches for default mappings aren't found in a Linear workspace, guiding users to manually configure the mapping in settings.",
            "status": "done"
          },
          {
            "id": 6,
            "title": "Write tests for various workflow configurations",
            "description": "Create comprehensive test suite covering standard and edge case workflow scenarios",
            "dependencies": [
              1,
              2,
              4,
              5
            ],
            "details": "Expand test coverage to focus on the direct mapping approach:\n\n1. Test direct mapping of 6 TaskMaster statuses to Linear state UUIDs:\n   - Verify correct mapping of each status to its corresponding UUID\n   - Test state resolution with exact name matching only\n   - Ensure consistent mapping across multiple resolution attempts\n\n2. Test configuration storage and retrieval:\n   - Verify UUID mappings are properly stored in configuration\n   - Test loading mappings from configuration during initialization\n   - Ensure configuration persistence across application restarts\n\n3. Test validation of state names:\n   - Verify state names exist in Linear workspace before mapping\n   - Test handling of renamed states in Linear\n   - Validate state name case sensitivity handling\n\n4. Test error handling:\n   - Test behavior when state mappings are missing\n   - Verify appropriate error messages for unmapped states\n   - Test recovery mechanisms when mappings become invalid\n\n5. Test setup wizard integration:\n   - Verify wizard correctly generates initial mappings\n   - Test user interface for manual mapping adjustments\n   - Ensure mappings are properly saved after wizard completion\n\nPerformance tests should focus on direct lookups and configuration access speed. Mock Linear workflows should use simple, representative state configurations with standard UUID formats.\n<info added on 2025-06-26T22:48:03.586Z>\nExpand test coverage to focus on the direct mapping approach:\n\n1. Test direct mapping of 6 TaskMaster statuses to Linear state UUIDs:\n   - Verify correct mapping of each status to its corresponding UUID\n   - Test state resolution with exact name matching only\n   - Ensure consistent mapping across multiple resolution attempts\n\n2. Test configuration storage and retrieval:\n   - Verify UUID mappings are properly stored in configuration\n   - Test loading mappings from configuration during initialization\n   - Ensure configuration persistence across application restarts\n\n3. Test validation of state names:\n   - Verify state names exist in Linear workspace before mapping\n   - Test handling of renamed states in Linear\n   - Validate state name case sensitivity handling\n\n4. Test error handling:\n   - Test behavior when state mappings are missing\n   - Verify appropriate error messages for unmapped states\n   - Test recovery mechanisms when mappings become invalid\n\n5. Test setup wizard integration:\n   - Verify wizard correctly generates initial mappings\n   - Test user interface for manual mapping adjustments\n   - Ensure mappings are properly saved after wizard completion\n\nPerformance tests should focus on direct lookups and configuration access speed. Mock Linear workflows should use simple, representative state configurations with standard UUID formats.\n</info added on 2025-06-26T22:48:03.586Z>",
            "status": "in-progress"
          },
          {
            "id": 7,
            "title": "Convert state names to state UUIDs in configuration",
            "description": "Update configuration system to store Linear state UUIDs instead of state names",
            "dependencies": [
              1,
              2
            ],
            "details": "Update the configuration system to store Linear state UUIDs directly instead of state names for the 6 TaskMaster statuses (Todo, In Progress, Blocked, In Review, Done, Canceled). Implement straightforward migration logic to convert existing name-based configurations to UUID-based configurations. Ensure all Linear API calls reference these UUIDs directly from the configuration when creating or updating issues. Focus on a simple, direct UUID lookup approach that minimizes complexity while maintaining backward compatibility during the transition period.",
            "status": "pending"
          },
          {
            "id": 8,
            "title": "Implement state mapping refresh mechanism",
            "description": "Create system to detect and handle changes in Linear workflow states",
            "dependencies": [
              7
            ],
            "details": "Develop logic to periodically check for changes in Linear workflow states. Update cached mappings when changes are detected. Implement notification system for breaking changes that require user intervention.\n<info added on 2025-06-26T22:47:52.400Z>\nDevelop logic to periodically check for changes in Linear workflow states. Update state mappings in configuration files when changes are detected. This mechanism should only run after the state names to UUID conversion (task 6.7) is complete, as it relies on the UUID configuration structure. Implement notification system for breaking changes that require user intervention.\n</info added on 2025-06-26T22:47:52.400Z>",
            "status": "pending"
          },
          {
            "id": 9,
            "title": "Integrate with setup wizard",
            "description": "Connect state mapping functionality with existing setup wizard",
            "dependencies": [
              7,
              8
            ],
            "details": "Enhance the existing linear-sync-setup command (the setup wizard) to include workflow state mapping configuration. The setup wizard should be the primary way users configure state mappings initially and also serve as the recommended recovery method if configurations become corrupted. Provide UI for reviewing and customizing state mappings during the setup flow. Include validation and testing options within the wizard to ensure proper mapping configuration before completion.",
            "status": "pending"
          },
          {
            "id": 10,
            "title": "Create command-line utilities for manual state mapping operations",
            "description": "Implement CLI commands for manually refreshing, validating, and debugging state mappings",
            "details": "Create command-line utilities that allow users to manually manage and troubleshoot state name mappings with Linear. Commands should include:\n\n1. 'linear-refresh-mappings': Regenerate UUID mappings from current configuration state names\n2. 'linear-validate-mappings': Check if configured state names exist in Linear\n3. 'linear-debug-mappings': Display current mappings and their status\n\nThese utilities should be simple and focused on the direct mapping functionality, providing clear feedback on mapping operations and errors. They serve as manual alternatives when automatic mapping needs verification or troubleshooting.",
            "status": "pending",
            "dependencies": [
              "6.7",
              "6.8"
            ],
            "parentTaskId": 6
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Task Status Update Synchronization",
        "description": "Replace mock status sync with real Linear API integration to update issue workflow states when Taskmaster status changes",
        "status": "pending",
        "dependencies": [
          4,
          6
        ],
        "priority": "high",
        "details": "Replace the current mock implementation in handleTaskStatusChanged with real Linear API calls. Map Taskmaster status to Linear state ID using stored mapping. Call linearClient.updateIssue(issueId, { stateId }) to move issue to new state. Handle special cases: deferred status (add label or keep in current state), cancelled status (use Canceled state or archive). Implement success/failure messaging. Ensure proper error handling if state ID not found or API call fails. Consider implementing status validation to prevent invalid transitions.",
        "testStrategy": "Test all status transitions with real Linear API. Verify correct state changes in Linear. Test error cases: invalid state ID, network failure, missing Linear issue ID. Test special status handling (deferred, cancelled). Compare behavior with previous mock implementation to ensure consistent user experience.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create status change event handler",
            "description": "Implement the main event handler function that listens for status changes in the system and triggers the appropriate Linear API updates",
            "dependencies": [],
            "details": "Create an event handler that captures status change events, extracts relevant issue information (ID, old status, new status), and orchestrates the update process. Include proper event validation and logging.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Implement status to state ID mapping",
            "description": "Create a mapping configuration that translates internal status values to Linear state IDs",
            "dependencies": [],
            "details": "Build a configuration object or mapping function that converts system status values (e.g., 'in_progress', 'completed') to corresponding Linear state IDs. Make this configurable and easy to maintain.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Replace mock API with real Linear API update calls",
            "description": "Replace the mock implementation with real API client methods to update issue states in Linear",
            "dependencies": [
              1,
              2
            ],
            "details": "Identify and remove the mock response code in handleTaskStatusChanged. Create functions that make authenticated HTTP requests to Linear's GraphQL API to update issue states. Include proper request formatting, authentication headers, and response parsing.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Handle special status cases (deferred, cancelled)",
            "description": "Implement special handling logic for deferred and cancelled status transitions",
            "dependencies": [
              3
            ],
            "details": "Add conditional logic to handle special cases like deferred (which may need to set a future date) and cancelled (which may need to archive or add labels). Ensure these cases are properly mapped to Linear's workflow.",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Add comprehensive error handling and testing",
            "description": "Implement robust error handling and create unit/integration tests for the status sync functionality",
            "dependencies": [
              4
            ],
            "details": "Add try-catch blocks, retry logic for transient failures, proper error logging, and fallback mechanisms. Write unit tests for mapping functions, integration tests for API calls, and end-to-end tests for the complete flow.",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Verify compatibility with existing task creation flow",
            "description": "Ensure the new status sync implementation works seamlessly with the existing task creation functionality",
            "dependencies": [
              3
            ],
            "details": "Test the integration between task creation and status updates to ensure they use consistent API approaches and state mappings. Verify that tasks created through the existing flow can have their statuses properly updated with the new implementation.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Subtask Creation and Hierarchy Sync",
        "description": "Create Linear sub-issues for Taskmaster subtasks maintaining parent-child relationships",
        "details": "Extend onTaskCreated to handle subtasks by detecting parent task ID. When creating subtask, include parentId in Linear createIssue call using parent's linearIssueId. Handle conversion of existing task to subtask by calling updateIssue with new parentId. Preserve subtask numbering in title if configured (e.g., '5.3: Subtask title'). Ensure proper error handling if parent task not synced yet. Implement batch subtask creation for parse-prd scenarios.",
        "testStrategy": "Test creating new subtasks under synced parent tasks. Test converting existing tasks to subtasks. Verify Linear shows correct parent-child relationships. Test error cases: parent not synced, invalid parent ID. Test bulk subtask creation",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Detect and handle parent-child relationships",
            "description": "Implement logic to identify and manage parent-child task relationships, including validation of parent existence and circular dependency prevention",
            "dependencies": [],
            "details": "Create functions to validate parent task existence, check for circular dependencies, and establish proper parent-child linkages in the data model",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Implement subtask creation with parent linking",
            "description": "Build functionality to create subtasks that automatically link to their parent tasks with proper relationship tracking",
            "dependencies": [
              1
            ],
            "details": "Develop API endpoints and business logic for creating subtasks, ensuring parent ID validation, automatic inheritance of relevant parent properties, and proper database relationship establishment",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Handle task-to-subtask conversion",
            "description": "Create mechanism to convert existing standalone tasks into subtasks of other tasks, including data migration and relationship updates",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement conversion logic that handles moving task data, updating relationships, preserving task history, and managing any dependent subtasks of the converted task",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Build batch subtask creation for bulk operations",
            "description": "Develop efficient bulk creation system for multiple subtasks with transaction support and rollback capabilities",
            "dependencies": [
              2
            ],
            "details": "Create batch processing logic with transaction boundaries, validation for all subtasks before commit, progress tracking, and error handling for partial failures",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Implement parent sync verification",
            "description": "Build verification system to ensure parent-child relationships remain consistent and handle orphaned subtasks",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Develop background jobs or triggers to verify parent existence, handle cascading updates/deletes, and implement orphan detection and resolution strategies",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Create tests for hierarchy scenarios",
            "description": "Develop comprehensive test suite covering all hierarchical relationship scenarios including edge cases and error conditions",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Write unit tests for relationship validation, integration tests for CRUD operations, performance tests for bulk operations, and edge case tests for circular dependencies and orphaned tasks",
            "status": "pending"
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Task Deletion and Archival Sync",
        "description": "Archive Linear issues when Taskmaster tasks are removed or cancelled",
        "details": "Create onTaskRemoved handler that calls linearClient.archiveIssue(issueId) when task is deleted. Handle both top-level tasks and subtasks removal. Implement similar logic for cancelled status (archive or move to Canceled state based on team workflow). Ensure proper error handling if Linear issue already archived or doesn't exist. Update success messages to indicate Linear archival. Consider implementing soft delete tracking to prevent accidental re-creation.",
        "testStrategy": "Test task removal with existing Linear issues. Verify issues are archived not deleted. Test removing subtasks and parent tasks. Test error cases: already archived issues, missing Linear ID. Verify cancelled status handling",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Priority and Label Synchronization",
        "description": "Sync task priorities to Linear and implement automatic labeling system for Taskmaster source, languages, and categories",
        "details": "Map Taskmaster priority (high/medium/low) to Linear's priority field in createIssue/updateIssue calls. Implement label creation and management: check if labels exist using linearClient.issueLabels(), create missing labels with appropriate colors. Apply 'Taskmaster' label to all synced issues. Implement language labeling based on config or project detection. Create category labels (Feature, Bug, Chore, Documentation, Testing, Research, Optimization) and apply based on task type or user input. Use GitHub's language colors for consistency. Make all labeling configurable via setup wizard preferences.",
        "testStrategy": "Test priority mapping for all levels. Test label creation with various names and colors. Verify labels are applied correctly to new and updated issues. Test with labels already existing in Linear. Test configuration toggles for each label type",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement priority field mapping",
            "description": "Create a mapping system to convert priority values from Linear issues to GitHub labels",
            "dependencies": [],
            "details": "Define priority levels (Urgent, High, Medium, Low, None) and create corresponding label names. Implement a function to map Linear's priority field values to GitHub label format.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Create label existence checking",
            "description": "Build functionality to check if labels already exist in the GitHub repository",
            "dependencies": [],
            "details": "Implement API calls to fetch existing labels from GitHub repository. Create a caching mechanism to avoid repeated API calls. Build comparison logic to check label existence by name.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Build label creation with color schemes",
            "description": "Implement label creation functionality with predefined color schemes for different label types",
            "dependencies": [
              2
            ],
            "details": "Define color palettes for priority labels, category labels, and language labels. Create GitHub API integration to create new labels. Handle rate limiting and error scenarios.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Implement category label system",
            "description": "Create a system to categorize issues based on content and apply appropriate category labels",
            "dependencies": [
              2,
              3
            ],
            "details": "Define categories like 'bug', 'feature', 'documentation', 'enhancement'. Implement logic to analyze issue title and description to determine categories. Create mapping between Linear issue types and GitHub categories.",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Add language detection and labeling",
            "description": "Implement language detection for code snippets and documentation to apply language-specific labels",
            "dependencies": [
              2,
              3
            ],
            "details": "Integrate language detection library or API. Scan issue content for code blocks and file references. Create and apply labels for detected programming languages.",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Create configuration-based label application",
            "description": "Build a configuration system to control which labels are applied based on user preferences",
            "dependencies": [
              1,
              4,
              5
            ],
            "details": "Create configuration schema for label rules. Implement rule engine to apply labels based on conditions. Add support for custom label mappings and exclusion rules.",
            "status": "pending"
          },
          {
            "id": 7,
            "title": "Write tests for label management",
            "description": "Create comprehensive test suite for all label management functionality",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Write unit tests for label mapping functions. Create integration tests for GitHub API interactions. Test edge cases like missing labels, API failures, and configuration errors.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 11,
        "title": "Implement Dependency Relationship Sync",
        "description": "Mirror Taskmaster task dependencies as Linear issue relations (blocking/blocked by)",
        "details": "After creating tasks, iterate through dependencies array and create Linear relations. Use linearClient.createIssueRelation(issueId, relatedIssueId, type: 'blocks') for each dependency. Handle bulk task creation by deferring relation creation until all tasks have Linear IDs. Implement duplicate relation detection to avoid creating same relation twice. Consider implementing relation removal when dependencies are removed in Taskmaster. Handle circular dependency detection if needed.",
        "testStrategy": "Test creating relations for tasks with single and multiple dependencies. Test bulk creation scenarios (parse-prd). Verify Linear shows correct blocking relationships. Test error cases: missing Linear IDs, circular dependencies. Test relation updates and removals",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Parse dependency arrays from tasks",
            "description": "Implement parsing logic to extract dependency information from task objects, handling various formats and validating dependency references",
            "dependencies": [],
            "details": "Create a parser that extracts dependency arrays from task objects, validates dependency IDs exist, and normalizes the dependency format for consistent processing",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Implement deferred relation creation for bulk ops",
            "description": "Build a system to queue and batch dependency relations for efficient bulk creation after all tasks are created",
            "dependencies": [
              1
            ],
            "details": "Design a deferred execution pattern that collects all dependency relations during task creation and executes them in optimized batches to minimize API calls",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Create Linear relation API calls",
            "description": "Implement the API integration layer to create task relations in Linear using their GraphQL API",
            "dependencies": [
              2
            ],
            "details": "Build GraphQL mutations for creating task relations, handle authentication, error responses, and implement retry logic for failed relation creations",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Add duplicate relation detection",
            "description": "Implement logic to detect and prevent duplicate dependency relations between tasks",
            "dependencies": [
              1,
              3
            ],
            "details": "Create a mechanism to track existing relations and check for duplicates before creating new ones, using efficient data structures for lookups",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Handle circular dependency edge cases",
            "description": "Implement detection and handling of circular dependencies to prevent infinite loops and invalid task graphs",
            "dependencies": [
              1,
              4
            ],
            "details": "Build a graph traversal algorithm to detect cycles in the dependency graph and provide appropriate error handling or resolution strategies",
            "status": "pending"
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement Branch Name Storage and Retrieval",
        "description": "Capture and store Linear's suggested branch names for git workflow integration",
        "details": "Modify createIssue response handling to extract branchName field. Store branch name in task's data structure in tasks.json. Ensure branch name is preserved during task updates. Consider displaying branch name in CLI output or task details. Implement branch name refresh in sync commands if Linear's naming scheme changes. Prepare foundation for future git integration features that could use stored branch names.",
        "testStrategy": "Test branch name extraction from Linear API responses. Verify branch names are stored correctly in tasks.json. Test with various issue titles to ensure branch name generation. Test branch name persistence through task updates",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Sync-Pending Command for Offline Recovery",
        "description": "Create command to retry syncing any tasks that failed to sync to Linear due to network issues or were created offline",
        "details": "Implement 'sync-pending' command that scans tasks.json for tasks without linearIssueId. For each unsynced task, attempt to create Linear issue using existing creation logic. Handle subtasks by ensuring parents are synced first. Implement progress reporting for bulk sync operations. Add rate limiting logic to avoid overwhelming Linear API. Store sync results and report summary at end. Consider implementing dry-run mode to preview what would be synced.",
        "testStrategy": "Test with mix of synced and unsynced tasks. Test parent-child sync ordering. Test rate limiting with large number of tasks. Verify error handling for partial sync failures. Test with tasks created while offline",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Scan for unsynced tasks in tasks.json",
            "description": "Implement functionality to scan tasks.json file and identify all tasks that haven't been synchronized yet based on sync status flags or timestamps",
            "dependencies": [],
            "details": "Create a scanner module that reads tasks.json, parses the JSON structure, and filters tasks based on sync status. Should handle large files efficiently and validate JSON structure.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Implement parent-first sync ordering",
            "description": "Develop logic to order tasks for synchronization ensuring parent tasks are processed before their children to maintain hierarchical integrity",
            "dependencies": [
              1
            ],
            "details": "Build a dependency graph of tasks, implement topological sorting to ensure parent tasks are synced first. Handle circular dependencies and orphaned tasks gracefully.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Add progress reporting for bulk operations",
            "description": "Create a progress reporting system that provides real-time feedback during bulk synchronization operations",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement progress bars, percentage completion, estimated time remaining, and current task being processed. Support both CLI and programmatic interfaces.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Implement rate limiting logic",
            "description": "Add rate limiting functionality to prevent overwhelming the sync endpoint and ensure compliance with API limits",
            "dependencies": [
              2
            ],
            "details": "Implement token bucket or sliding window rate limiting algorithm. Make limits configurable and add automatic retry with exponential backoff for rate limit errors.",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Create dry-run mode option",
            "description": "Implement a dry-run mode that simulates the sync operation without making actual changes, allowing users to preview what will be synchronized",
            "dependencies": [
              1,
              2,
              4
            ],
            "details": "Add --dry-run flag that processes all sync logic but skips actual API calls. Generate detailed preview report of what would be synced, including task counts and hierarchy.",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Build comprehensive sync reporting",
            "description": "Create detailed reporting functionality that logs all sync operations, successes, failures, and provides actionable summary reports",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Generate sync reports with statistics, error logs, successful sync counts, failed items with reasons, and performance metrics. Support multiple output formats (JSON, CSV, HTML).",
            "status": "pending"
          }
        ]
      },
      {
        "id": 14,
        "title": "Implement Complexity to Story Points Mapping",
        "description": "Map Taskmaster's complexity analysis to Linear's estimate field for story point tracking",
        "details": "Analyze Taskmaster's complexity scoring system and create mapping to Fibonacci story points (1, 2, 3, 5, 8, 13). Implement complexity detection from task data or AI analysis results. Add estimate field to createIssue and updateIssue calls when available. Make mapping configurable (small=1, medium=3, large=5, etc.). Consider implementing reverse sync to calibrate AI complexity estimates based on actual effort. Default to 1 point if no complexity data available.",
        "testStrategy": "Test complexity to story point conversions for various task complexities. Verify estimates appear correctly in Linear. Test with tasks lacking complexity data. Test custom mapping configurations",
        "priority": "low",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Add Integration Points to All Taskmaster Commands",
        "description": "Extend integration hooks to all relevant Taskmaster commands beyond the initial addTask proof of concept",
        "details": "Add integration manager event emissions to: remove-task, remove-subtask, set-status, parse-prd (bulk creation), and any task update commands. Ensure consistent error handling across all commands. Implement proper event data structure for each command type. Handle edge cases like moving tasks between parents or converting tasks to subtasks. Ensure all commands show appropriate sync success/failure messages.",
        "testStrategy": "Test each command with Linear sync enabled and disabled. Verify correct events are emitted with proper data. Test error scenarios for each command. Ensure local operations succeed even if sync fails",
        "priority": "high",
        "dependencies": [
          3,
          4,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add hooks to remove-task command",
            "description": "Implement hook system in the remove-task command to allow for extensibility and event handling",
            "dependencies": [],
            "details": "Modify the remove-task command to include pre and post execution hooks. Ensure hooks are called at appropriate points in the command execution flow. Document the hook interface for future extensions.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Integrate remove-subtask command",
            "description": "Create and implement the remove-subtask command with proper validation and data handling",
            "dependencies": [
              1
            ],
            "details": "Develop a new command to remove subtasks from existing tasks. Include validation to prevent orphaned dependencies. Implement confirmation prompts for safety. Ensure proper updates to task data structures.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Hook set-status command",
            "description": "Add hook functionality to the set-status command for better integration with other components",
            "dependencies": [
              1
            ],
            "details": "Implement pre and post execution hooks in the set-status command. Ensure status changes trigger appropriate events. Allow for custom validation or processing through hooks.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Integrate parse-prd bulk operations",
            "description": "Enhance the parse-prd command to handle bulk operations efficiently",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Modify the parse-prd command to process multiple items in a single execution. Implement batching for performance. Add progress indicators for long-running operations. Ensure proper error collection during bulk processing.",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Handle task update commands",
            "description": "Implement or improve commands for updating existing tasks with proper validation",
            "dependencies": [
              1,
              3
            ],
            "details": "Create or enhance commands for updating task properties. Implement validation to maintain data integrity. Ensure updates propagate correctly to dependent entities. Add confirmation for destructive changes.",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Implement edge case handling",
            "description": "Add robust handling for edge cases across all commands",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Identify and implement handling for edge cases such as circular dependencies, empty inputs, and conflicting operations. Add graceful degradation for unexpected scenarios. Document all edge cases and their handling.",
            "status": "pending"
          },
          {
            "id": 7,
            "title": "Ensure consistent error handling",
            "description": "Standardize error handling across all commands for better user experience",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Create a unified error handling system. Implement consistent error messages and formatting. Add appropriate logging for debugging. Ensure errors provide actionable information to users.",
            "status": "pending"
          },
          {
            "id": 8,
            "title": "Add comprehensive testing for all commands",
            "description": "Create thorough test suite covering all commands and their interactions",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Develop unit tests for each command. Create integration tests for command interactions. Implement test cases for identified edge cases. Add performance tests for bulk operations. Ensure test coverage meets project standards.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 16,
        "title": "Implement Robust Error Handling and Logging",
        "description": "Create comprehensive error handling system for all Linear API interactions with user-friendly messaging",
        "details": "Wrap all Linear API calls in try-catch blocks with specific error type handling. Implement error categorization: network errors, authentication errors, validation errors, rate limits. Create user-friendly error messages without exposing sensitive data. Implement retry logic with exponential backoff for transient failures. Add [Linear Sync] prefix to all sync-related console output. Implement session-based error suppression to avoid spam. Log detailed errors to file for debugging while showing concise messages to users.",
        "testStrategy": "Test with various error scenarios: invalid API key, network timeout, rate limiting, malformed requests. Verify error messages are helpful and non-technical. Test retry logic with intermittent failures. Ensure no sensitive data in error output",
        "priority": "high",
        "dependencies": [
          4,
          7,
          8,
          9,
          10,
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create error categorization system",
            "description": "Design and implement a comprehensive error categorization system that classifies errors by type (network, authentication, validation, etc.), severity, and source",
            "dependencies": [],
            "details": "Define error types enum, create error classes hierarchy, implement error code mapping for different services (Linear, GitHub, Slack), and establish severity levels for proper handling",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Implement retry logic with backoff",
            "description": "Build a robust retry mechanism with exponential backoff for transient failures across all external service calls",
            "dependencies": [
              1
            ],
            "details": "Create retry decorator/wrapper, implement exponential backoff algorithm, configure max retry attempts per error type, add jitter to prevent thundering herd, and handle rate limiting responses",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Build user-friendly error messages",
            "description": "Create a system for translating technical errors into clear, actionable user messages with helpful context and resolution steps",
            "dependencies": [
              1
            ],
            "details": "Design error message templates, implement error context enrichment, create user action suggestions, add error recovery instructions, and ensure consistent formatting across all error types",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Add file-based error logging",
            "description": "Implement a file-based error logging system with rotation, structured formatting, and appropriate detail levels",
            "dependencies": [
              1,
              3
            ],
            "details": "Set up log file rotation policy, implement structured JSON logging format, add error context serialization, create log severity filtering, and ensure sensitive data is sanitized",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Implement session-based error suppression",
            "description": "Build a mechanism to suppress repetitive errors within a session to prevent notification spam while maintaining error visibility",
            "dependencies": [
              1,
              4
            ],
            "details": "Create session error tracking cache, implement error deduplication logic, define suppression rules per error type, add error count aggregation, and ensure critical errors bypass suppression",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Create [Linear Sync] output formatting",
            "description": "Design and implement consistent error output formatting specifically for Linear sync operations with clear visual indicators",
            "dependencies": [
              3,
              5
            ],
            "details": "Define Linear-specific error format templates, implement color coding for error severity, add sync operation context, create progress indicators with error states, and ensure compatibility with Linear's UI patterns",
            "status": "pending"
          },
          {
            "id": 7,
            "title": "Write error scenario tests",
            "description": "Develop comprehensive test suite covering all error scenarios including edge cases, recovery paths, and integration failures",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Create unit tests for error categorization, test retry logic with various failure patterns, validate error message generation, test log file operations, verify session suppression behavior, and add integration tests for full error flow",
            "status": "pending"
          }
        ]
      },
      {
        "id": 17,
        "title": "Create Comprehensive Documentation and Help System",
        "description": "Write user documentation, API documentation, and update CLI help text for all Linear sync features",
        "details": "Create Linear Integration section in README with setup instructions, feature overview, and limitations. Document all new commands (sync-setup, sync-pending) with examples. Add integration-specific help to CLI (--help output). Create troubleshooting guide for common issues. Document configuration options and environment variables. Include architecture diagrams and sequence diagrams. Write migration guide for existing Taskmaster users. Document one-way sync limitations clearly.",
        "testStrategy": "Review documentation for completeness and accuracy. Test all documented commands and examples. Verify help text appears correctly in CLI. Get feedback from test users on documentation clarity",
        "priority": "medium",
        "dependencies": [
          5,
          13,
          15
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Write Linear Integration README section",
            "description": "Create comprehensive documentation for Linear integration features including setup, configuration, and usage instructions",
            "dependencies": [],
            "details": "Document OAuth setup process, API key configuration, available Linear commands, sync functionality, and integration workflows. Include code snippets and configuration examples.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Document all new commands with examples",
            "description": "Create detailed documentation for each new CLI command with usage examples and expected outputs",
            "dependencies": [],
            "details": "Document command syntax, available flags/options, use cases, example inputs/outputs, and error handling for each new command. Include both basic and advanced usage scenarios.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Update CLI help text",
            "description": "Revise and update all CLI help messages to reflect new commands and functionality",
            "dependencies": [
              2
            ],
            "details": "Update command descriptions, flag explanations, usage examples in --help output. Ensure consistency across all commands and proper formatting for terminal display.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Create troubleshooting guide",
            "description": "Develop comprehensive troubleshooting documentation covering common issues and solutions",
            "dependencies": [
              1,
              2
            ],
            "details": "Document common error messages, debugging steps, FAQ section, known issues/limitations, and recovery procedures. Include specific Linear integration troubleshooting scenarios.",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Add architecture diagrams",
            "description": "Create visual diagrams illustrating system architecture and data flow",
            "dependencies": [],
            "details": "Design component interaction diagrams, data flow charts, Linear integration architecture, and CLI command structure diagrams. Use standard diagramming tools and export in multiple formats.",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Write migration guide for existing users",
            "description": "Create step-by-step migration guide for users upgrading from previous versions",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Document breaking changes, migration steps, data backup procedures, configuration updates needed, and rollback procedures. Include version compatibility matrix and upgrade paths.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 18,
        "title": "Implement Performance Optimizations and Rate Limiting",
        "description": "Optimize bulk operations and implement rate limiting to handle large-scale task synchronization efficiently",
        "details": "Implement rate limiting with configurable requests per minute (default 50). Add request queuing with priority for user-initiated vs background sync. Optimize bulk operations by batching where possible (though Linear lacks bulk create). Implement progress indicators for long-running operations. Add caching for frequently accessed data (team states, labels). Consider implementing parallel processing for independent operations. Monitor and log performance metrics for future optimization.",
        "testStrategy": "Test with large PRD parsing (50+ tasks). Measure sync performance and API call counts. Test rate limiting triggers and recovery. Verify progress indicators work correctly. Test cache invalidation scenarios",
        "priority": "medium",
        "dependencies": [
          4,
          13,
          15
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement request rate limiting queue",
            "description": "Create a queue system to manage API request rates and prevent overwhelming the server",
            "dependencies": [],
            "details": "Implement a token bucket or sliding window algorithm for rate limiting. Include configurable limits per endpoint, request queuing with timeout handling, and automatic retry logic for rate-limited requests",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Add request prioritization system",
            "description": "Build a priority-based request handling system to ensure critical operations are processed first",
            "dependencies": [
              1
            ],
            "details": "Create priority levels (high, medium, low), implement priority queue data structure, add request classification logic based on operation type, and ensure high-priority requests bypass rate limiting when necessary",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Create progress indicators for long operations",
            "description": "Implement visual feedback system for operations that take significant time to complete",
            "dependencies": [],
            "details": "Design progress bar components, implement WebSocket or SSE for real-time updates, create progress tracking for bulk operations, file uploads, and data processing tasks, include estimated time remaining calculations",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Build caching layer for frequent data",
            "description": "Implement a comprehensive caching system to reduce redundant API calls and improve response times",
            "dependencies": [],
            "details": "Set up in-memory cache with TTL support, implement cache invalidation strategies, create cache warming for frequently accessed data, add cache hit/miss metrics, and implement cache persistence for offline support",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Optimize bulk operations",
            "description": "Enhance performance for operations involving multiple items or large datasets",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement batch processing with configurable chunk sizes, add parallel processing where applicable, optimize database queries for bulk operations, implement streaming for large data exports, and add bulk operation rollback capabilities",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Add performance monitoring",
            "description": "Create comprehensive monitoring system to track application performance metrics",
            "dependencies": [
              1,
              2,
              4,
              5
            ],
            "details": "Implement API response time tracking, monitor memory usage and CPU utilization, track cache performance metrics, create performance dashboards, set up alerting for performance degradation, and log slow queries",
            "status": "pending"
          },
          {
            "id": 7,
            "title": "Write performance tests",
            "description": "Develop comprehensive test suite to validate performance optimizations and prevent regressions",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Create load tests for API endpoints, implement stress tests for bulk operations, write benchmark tests for critical paths, test cache effectiveness, validate rate limiting behavior, and establish performance baselines",
            "status": "pending"
          }
        ]
      },
      {
        "id": 19,
        "title": "Build Extensible Plugin Architecture Foundation",
        "description": "Refactor integration code to support future integrations beyond Linear while maintaining backward compatibility",
        "details": "Extract Linear-specific code into a plugin module following defined interface. Create abstract Integration base class with standard methods: onTaskCreated, onTaskUpdated, etc. Implement plugin registration and discovery mechanism. Move Linear-specific commands to plugin directory. Create example stub integration to validate architecture. Document plugin development guide. Ensure core Taskmaster changes are minimal and maintainable. Consider npm package structure for distributing integrations.",
        "testStrategy": "Test plugin loading and registration. Verify Linear integration works identically after refactoring. Test with multiple mock integrations registered. Ensure plugin failures don't affect core functionality",
        "priority": "low",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design plugin interface specification",
            "description": "Create a comprehensive specification for the plugin interface that defines how integrations will interact with the core system.",
            "dependencies": [],
            "details": "Define required methods, event hooks, data structures, and communication protocols. Consider versioning strategy, error handling, and security boundaries. Document expected behaviors and constraints for plugin developers.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Create abstract Integration base class",
            "description": "Develop an abstract base class that all integration plugins will inherit from to ensure consistent implementation.",
            "dependencies": [
              1
            ],
            "details": "Implement required interface methods, provide utility functions, establish error handling patterns, and define lifecycle hooks. Include documentation for each method and property. Ensure the base class is flexible enough for various integration types while enforcing necessary constraints.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Refactor Linear code into plugin module",
            "description": "Extract existing Linear integration code into a separate plugin module following the new architecture.",
            "dependencies": [
              2
            ],
            "details": "Move Linear-specific code to a dedicated directory structure. Adapt the code to use the new base class and interface. Ensure all functionality is preserved while conforming to the new plugin structure. Update imports and references throughout the codebase.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Implement plugin registration mechanism",
            "description": "Create a system for plugins to register themselves with the core application at runtime.",
            "dependencies": [
              1,
              2
            ],
            "details": "Develop a registry class to track available plugins. Implement methods for plugins to register and deregister. Add validation to ensure plugins meet interface requirements. Create activation/deactivation hooks for proper lifecycle management.",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Build plugin discovery system",
            "description": "Implement a mechanism to automatically discover and load available plugins.",
            "dependencies": [
              4
            ],
            "details": "Create a system to scan designated directories for plugin modules. Implement dynamic loading capabilities. Add configuration options for plugin paths. Include error handling for malformed plugins. Support both built-in and user-installed plugins.",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Create example stub integration",
            "description": "Develop a simple example integration that demonstrates how to implement the plugin interface.",
            "dependencies": [
              2,
              4
            ],
            "details": "Build a minimal working plugin that implements all required interfaces. Include comprehensive comments explaining each implementation detail. Create a template that can be used as a starting point for new integrations. Test thoroughly to ensure it works with the registration system.",
            "status": "pending"
          },
          {
            "id": 7,
            "title": "Move Linear commands to plugin",
            "description": "Migrate all Linear-specific commands to operate within the new plugin architecture.",
            "dependencies": [
              3,
              4
            ],
            "details": "Update command registration to work through the plugin system. Ensure commands are only available when the plugin is active. Adapt command implementations to use the plugin's API rather than direct integration. Test thoroughly to verify all functionality works as before.",
            "status": "pending"
          },
          {
            "id": 8,
            "title": "Write plugin development guide",
            "description": "Create comprehensive documentation for developers who want to build new integration plugins.",
            "dependencies": [
              1,
              2,
              6
            ],
            "details": "Document the plugin interface, base class usage, lifecycle hooks, and best practices. Include step-by-step tutorials with code examples. Explain the registration process and discovery mechanism. Provide troubleshooting guidance and common pitfalls to avoid.",
            "status": "pending"
          },
          {
            "id": 9,
            "title": "Ensure backward compatibility",
            "description": "Verify that the refactored system maintains compatibility with existing configurations and workflows.",
            "dependencies": [
              3,
              7
            ],
            "details": "Create comprehensive tests for all existing functionality. Implement compatibility layers where necessary. Verify that existing configurations continue to work. Document any breaking changes and provide migration paths. Test with various user scenarios to ensure seamless transition.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 20,
        "title": "Implement Comprehensive Testing Suite",
        "description": "Create unit tests, integration tests, and end-to-end tests for all Linear sync functionality",
        "details": "Set up testing framework (Jest or Mocha) with Linear SDK mocking. Write unit tests for all integration functions with >80% coverage. Create integration tests using Linear sandbox environment. Implement end-to-end tests for common workflows. Add CI/CD pipeline for automated testing. Create test data generators for various task scenarios. Implement regression tests for bug fixes. Consider snapshot testing for API payloads.",
        "testStrategy": "Run full test suite before each release. Monitor test coverage metrics. Perform manual testing of critical paths. Load test with realistic data volumes. Security test API key handling",
        "priority": "high",
        "dependencies": [
          16,
          17
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up testing framework with mocking",
            "description": "Configure a testing framework that supports mocking capabilities for isolating components during testing",
            "dependencies": [],
            "details": "Select and install appropriate testing framework (Jest, Mocha, etc.). Set up mock libraries (Sinon, Jest mocks, etc.). Configure the testing environment with proper directory structure. Create mock configuration files. Set up test runners and basic test utilities.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Write unit tests for all functions",
            "description": "Create comprehensive unit tests for all individual functions in the codebase",
            "dependencies": [
              1
            ],
            "details": "Identify all functions requiring tests. Write test cases covering normal operation, edge cases, and error handling. Implement mocks for external dependencies. Ensure proper isolation of units being tested. Aim for high function coverage.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Create integration tests with sandbox",
            "description": "Develop integration tests using a sandbox environment to test interactions between components",
            "dependencies": [
              1
            ],
            "details": "Set up sandbox environment that mimics production. Create tests that verify correct interaction between multiple components. Configure database/API sandboxes. Test data flow between integrated components. Verify system behavior across component boundaries.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Build end-to-end test scenarios",
            "description": "Develop comprehensive end-to-end tests that validate complete user workflows",
            "dependencies": [
              1,
              3
            ],
            "details": "Identify critical user journeys to test. Set up end-to-end testing tools (Cypress, Selenium, etc.). Create automated tests that simulate real user behavior. Test complete workflows from start to finish. Include cross-browser/device testing if applicable.",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Create test data generators",
            "description": "Implement utilities to generate realistic test data for various testing scenarios",
            "dependencies": [
              1
            ],
            "details": "Create factories or fixtures for generating test data. Implement randomized data generation with proper constraints. Support various data scenarios (empty, boundary, invalid). Create helpers for common test data patterns. Ensure data generators are reusable across test suites.",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Implement regression tests",
            "description": "Create a suite of regression tests to prevent previously fixed bugs from reoccurring",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Identify past bugs and issues from project history. Create specific tests that would catch these issues if reintroduced. Organize regression tests by feature area. Ensure tests are maintainable and clearly document which bug they prevent. Automate regression test execution.",
            "status": "pending"
          },
          {
            "id": 7,
            "title": "Set up CI/CD pipeline",
            "description": "Configure continuous integration and deployment pipeline with automated test execution",
            "dependencies": [
              1,
              2
            ],
            "details": "Select CI/CD platform (GitHub Actions, Jenkins, etc.). Configure automated test runs on code commits. Set up different test stages (unit, integration, e2e). Configure notifications for test failures. Optimize pipeline for speed and reliability. Set quality gates based on test results.",
            "status": "pending"
          },
          {
            "id": 8,
            "title": "Add coverage reporting",
            "description": "Implement test coverage reporting to identify untested code areas",
            "dependencies": [
              2,
              3,
              4,
              6,
              7
            ],
            "details": "Configure code coverage tools (Istanbul, Jest coverage, etc.). Set up coverage reports generation. Integrate coverage reporting with CI/CD pipeline. Configure coverage thresholds for quality gates. Create visualizations of coverage metrics. Document coverage goals and exclusions.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 21,
        "title": "Conduct Security Audit and Hardening",
        "description": "Review and enhance security measures for API key storage, data transmission, and user input handling",
        "details": "Audit API key storage and ensure proper file permissions on .env. Implement key rotation reminders. Review all user inputs for injection vulnerabilities. Ensure HTTPS for all API communications. Implement request signing if supported by Linear. Add security headers to any HTTP requests. Document security best practices for users. Consider implementing key encryption at rest. Review npm dependencies for known vulnerabilities.",
        "testStrategy": "Perform security scanning with tools like npm audit. Test with malformed inputs and injection attempts. Verify API keys are never logged or exposed. Test file permission enforcement. Penetration test if resources allow",
        "priority": "high",
        "dependencies": [
          20
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit API key storage security",
            "description": "Review and validate how API keys are stored, ensuring they follow security best practices",
            "dependencies": [],
            "details": "Examine current API key storage implementation, verify encryption at rest, check access controls, validate environment variable usage, and ensure keys are not exposed in logs or version control",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Review input validation for injections",
            "description": "Analyze all user input points for potential injection vulnerabilities",
            "dependencies": [],
            "details": "Identify all input vectors, test for SQL injection, XSS, command injection, and other injection attacks. Implement proper sanitization and validation mechanisms",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Implement key rotation reminders",
            "description": "Create a system to remind users to rotate their API keys periodically",
            "dependencies": [
              1
            ],
            "details": "Design and implement notification system for key rotation, set up configurable rotation periods, create UI components for rotation reminders, and track key age",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Ensure HTTPS enforcement",
            "description": "Verify and enforce HTTPS usage across all application endpoints",
            "dependencies": [],
            "details": "Configure SSL/TLS properly, implement HSTS headers, ensure all API calls use HTTPS, redirect HTTP to HTTPS, and validate certificate configuration",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Add security headers",
            "description": "Implement comprehensive security headers to protect against common attacks",
            "dependencies": [
              4
            ],
            "details": "Add headers including Content-Security-Policy, X-Frame-Options, X-Content-Type-Options, Referrer-Policy, and Permissions-Policy. Test header effectiveness",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Review dependency vulnerabilities",
            "description": "Scan and address security vulnerabilities in third-party dependencies",
            "dependencies": [],
            "details": "Run dependency vulnerability scans, review CVE reports, update vulnerable packages, implement automated dependency checking in CI/CD pipeline",
            "status": "pending"
          },
          {
            "id": 7,
            "title": "Document security best practices",
            "description": "Create comprehensive security documentation for the project",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Document security architecture, API key handling guidelines, input validation practices, HTTPS configuration, security headers implementation, and dependency management procedures",
            "status": "pending"
          }
        ]
      },
      {
        "id": 22,
        "title": "Implement Sync Status Audit Command",
        "description": "Create diagnostic command to verify sync status and detect any divergence between Taskmaster and Linear",
        "details": "Implement 'sync-status' or 'sync-audit' command that compares local tasks with Linear issues. Fetch all tasks with linearIssueId and verify they exist in Linear. Check for status mismatches between local and remote. Detect orphaned Linear issues without local tasks. Report any discrepancies with actionable recommendations. Option to fix simple discrepancies automatically. Include performance metrics and last sync timestamps.",
        "testStrategy": "Test with various divergence scenarios: deleted Linear issues, status mismatches, orphaned issues. Verify recommendations are accurate and helpful. Test performance with large task lists",
        "priority": "low",
        "dependencies": [
          4,
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create sync-status command structure",
            "description": "Set up the CLI command structure for sync-status with necessary options and arguments",
            "dependencies": [],
            "details": "Create a new command handler for 'sync-status' that accepts options like --project-id, --fix, --verbose. Set up the basic command structure with proper help text and option parsing. Include subcommands for different status check types (all, orphaned, mismatched).",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Implement Linear issue verification",
            "description": "Build functionality to verify and fetch Linear issues for comparison with local data",
            "dependencies": [
              1
            ],
            "details": "Create Linear API client methods to fetch issues by project, including their current status, assignee, labels, and other metadata. Implement batch fetching for large projects. Add error handling for API rate limits and network issues. Cache fetched data for efficient comparison.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Build status comparison logic",
            "description": "Develop the core logic to compare Linear issues with local task states",
            "dependencies": [
              2
            ],
            "details": "Create comparison algorithms to match Linear issues with local tasks by ID or other identifiers. Compare fields like status, title, description, assignee, and labels. Define rules for what constitutes a mismatch. Handle edge cases like deleted or archived issues.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Detect orphaned issues",
            "description": "Implement detection for issues that exist in Linear but not locally, or vice versa",
            "dependencies": [
              3
            ],
            "details": "Build logic to identify orphaned issues in both directions (Linear-only and local-only). Create categorization for different types of orphans (deleted locally, never synced, failed sync). Add filtering options to exclude intentionally unsynced issues.",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Create discrepancy reporting",
            "description": "Build comprehensive reporting system for sync status and discrepancies",
            "dependencies": [
              4
            ],
            "details": "Design report formats (console table, JSON, CSV) showing sync status summary, detailed discrepancies, and orphaned issues. Include statistics like sync percentage, last sync time, and error counts. Add color coding for console output to highlight issues. Implement export functionality for reports.",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Add auto-fix capabilities for simple issues",
            "description": "Implement automated resolution for common sync discrepancies",
            "dependencies": [
              5
            ],
            "details": "Create fix strategies for simple issues like status mismatches, missing labels, or outdated titles. Implement dry-run mode to preview fixes before applying. Add confirmation prompts for destructive operations. Log all auto-fix actions for audit trail. Include rollback capability for applied fixes.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 23,
        "title": "Polish User Experience and Feedback Messages",
        "description": "Refine all user-facing messages, add color coding, implement progress indicators, and ensure consistent UX",
        "details": "Implement consistent color scheme using chalk: green for success, yellow for warnings, red for errors. Add spinner/progress bars for long operations using ora or similar. Standardize message format across all commands. Implement verbose and quiet modes. Add emoji support for better visual feedback (optional). Ensure all messages are concise yet informative. Add contextual help hints. Implement smart error recovery suggestions.",
        "testStrategy": "Review all user messages for clarity and consistency. Test color output on various terminals. Verify progress indicators don't interfere with CI/CD logs. Get user feedback on message clarity",
        "priority": "medium",
        "dependencies": [
          16,
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Prepare Production Release and Deployment",
        "description": "Finalize code, conduct final testing, prepare release artifacts, and deploy the Linear sync feature",
        "details": "Conduct final code review and cleanup. Update version numbers and changelogs. Create release notes highlighting features and known limitations. Package distribution artifacts (npm package or binary). Set up release automation if needed. Create user onboarding materials. Plan rollout strategy (beta users first?). Prepare support documentation and FAQs. Set up monitoring for production issues. Create feedback collection mechanism.",
        "testStrategy": "Full regression testing on multiple platforms. User acceptance testing with beta users. Performance testing under production-like load. Verify installation and setup process. Monitor initial production usage closely",
        "priority": "high",
        "dependencies": [
          20,
          21,
          22,
          23
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Conduct final code review",
            "description": "Perform comprehensive code review of all changes targeted for release, ensuring code quality, security, and adherence to standards",
            "dependencies": [],
            "details": "Review all pull requests, check for code smells, security vulnerabilities, performance issues, and ensure proper test coverage. Document any findings and ensure all critical issues are resolved before proceeding",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Update version and changelogs",
            "description": "Update version numbers across all relevant files and compile comprehensive changelog documenting all changes, fixes, and new features",
            "dependencies": [
              1
            ],
            "details": "Follow semantic versioning conventions, update version in package files, configuration files, and documentation. Create detailed changelog entries categorized by type (features, fixes, breaking changes)",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Create release notes",
            "description": "Write user-facing release notes highlighting key features, improvements, known issues, and migration instructions",
            "dependencies": [
              2
            ],
            "details": "Draft release notes for different audiences (end users, developers, administrators). Include upgrade instructions, breaking changes, deprecation notices, and links to detailed documentation",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Package distribution artifacts",
            "description": "Build and package all distribution artifacts including binaries, containers, documentation, and deployment scripts",
            "dependencies": [
              1,
              2
            ],
            "details": "Create production builds, generate Docker images, compile documentation, bundle dependencies, create installation packages for different platforms, and verify artifact integrity",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Set up release automation",
            "description": "Configure CI/CD pipelines for automated release processes including building, testing, and deploying artifacts",
            "dependencies": [
              4
            ],
            "details": "Set up automated workflows for version tagging, artifact building, security scanning, automated testing, and deployment to staging/production environments. Configure rollback mechanisms",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Create onboarding materials",
            "description": "Develop comprehensive onboarding documentation, tutorials, and quick-start guides for new users and developers",
            "dependencies": [
              3
            ],
            "details": "Create getting started guides, API documentation, video tutorials, sample projects, troubleshooting guides, and FAQ sections. Ensure materials cover common use cases and integration scenarios",
            "status": "pending"
          },
          {
            "id": 7,
            "title": "Plan rollout strategy",
            "description": "Design phased rollout plan including deployment schedule, feature flags, canary releases, and rollback procedures",
            "dependencies": [
              5
            ],
            "details": "Define rollout phases, identify pilot users, set success criteria, plan communication strategy, schedule maintenance windows, prepare rollback plans, and coordinate with stakeholders",
            "status": "pending"
          },
          {
            "id": 8,
            "title": "Set up production monitoring",
            "description": "Implement comprehensive monitoring, alerting, and observability solutions for production environment",
            "dependencies": [
              5
            ],
            "details": "Configure application performance monitoring, set up log aggregation, create dashboards for key metrics, establish alerting rules, implement error tracking, and set up on-call procedures",
            "status": "pending"
          }
        ]
      },
      {
        "id": 25,
        "title": "Implement Git Integration Proof of Concept",
        "description": "Create example integration showing how the plugin architecture can support git branch automation",
        "details": "Create GitIntegration plugin that listens to taskStatusChanged events. When status changes to 'in-progress', automatically create and checkout git branch using stored branchName. Implement safety checks: ensure clean working directory, confirm with user. Use simple-git npm package or shell commands. Make feature opt-in via configuration. Document as example for community plugin development. Consider additional features: auto-commit on task completion, PR creation.",
        "testStrategy": "Test git operations in various repository states. Verify branch creation with different branch name formats. Test error handling for dirty working directory. Ensure feature can be disabled completely",
        "priority": "low",
        "dependencies": [
          12,
          19
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create GitIntegration plugin structure",
            "description": "Set up the basic plugin architecture for GitIntegration following the established plugin pattern",
            "dependencies": [],
            "details": "Create plugin directory structure, implement base plugin class extending from Plugin interface, define plugin metadata and lifecycle methods (initialize, activate, deactivate)",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Implement branch creation on status change",
            "description": "Add functionality to automatically create git branches when task status changes",
            "dependencies": [
              1
            ],
            "details": "Listen to task status change events, generate branch names based on task ID and status, implement branch creation logic with error handling",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Add working directory safety checks",
            "description": "Implement validation to ensure git operations are performed safely",
            "dependencies": [
              1
            ],
            "details": "Check for uncommitted changes before branch operations, verify repository exists and is valid, implement rollback mechanisms for failed operations, add user prompts for destructive actions",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Integrate simple-git library",
            "description": "Add and configure simple-git library for git operations",
            "dependencies": [
              1
            ],
            "details": "Install simple-git as dependency, create git service wrapper, implement core git operations (branch, checkout, status), add error handling for git commands",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Create opt-in configuration",
            "description": "Implement configuration system for users to enable/disable git integration features",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Add configuration schema for git integration settings, create UI for enabling/disabling features, implement per-project git settings, add validation for configuration values",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Document as plugin example",
            "description": "Create comprehensive documentation showcasing GitIntegration as a plugin architecture example",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Write plugin development guide using GitIntegration as reference, document API usage and extension points, create code examples and best practices, add troubleshooting section for common issues",
            "status": "pending"
          }
        ]
      },
      {
        "id": 26,
        "title": "Implement Code Quality Improvements",
        "description": "Enhance code quality through CI pipeline improvements, security scanning, automated dependency updates, pre-commit hooks, linting rule enforcement, and Node.js version testing.",
        "details": "This task involves implementing several code quality improvements:\n\n1. **Coverage Thresholds in CI**:\n   - Remove the override in CI configuration that sets coverage thresholds to 0%\n   - Utilize the proper 80% thresholds already defined in jest.config.js\n   - Update CI pipeline configuration files to respect these thresholds\n   - Ensure test failures occur when coverage drops below thresholds\n\n2. **Security Scanning**:\n   - Add npm audit security scanning to the CI pipeline\n   - Configure with moderate audit level to catch significant vulnerabilities\n   - Update CI configuration to fail builds on moderate or higher security issues\n   - Document any necessary exceptions or suppressions for false positives\n\n3. **Dependabot Configuration**:\n   - Create .github/dependabot.yml configuration file\n   - Configure for weekly dependency update schedule\n   - Set up appropriate version update strategy (e.g., patch and minor updates automatically)\n   - Configure PR labels and assignees for dependency updates\n   - Set reasonable open PR limits to prevent overwhelming the team\n\n4. **Pre-commit Hooks**:\n   - Install and configure Husky for Git hooks management\n   - Set up lint-staged to run linters only on staged files\n   - Configure pre-commit hooks to run:\n     - Linting (Biome)\n     - Type checking (TypeScript)\n     - Unit tests affected by changes\n     - Format checking\n   - Document the pre-commit hook setup in the README\n\n5. **Re-enable Critical Biome Linting Rules**:\n   - Change the following rules from \"off\" to \"warn\":\n     - noForEach\n     - useOptionalChain\n     - noUnreachable\n   - Update Biome configuration files\n   - Run linter against codebase to identify existing violations\n   - Fix critical violations before enabling rules\n\n6. **Node.js Matrix Testing**:\n   - Update CI configuration to test against Node.js versions 18, 20, and 22\n   - Configure matrix testing in GitHub Actions or other CI system\n   - Ensure all dependencies are compatible with these Node versions\n   - Handle any version-specific code or configuration needed\n\nThe implementation should prioritize minimal disruption to developer workflow while maximizing code quality benefits. Document all changes thoroughly and provide clear error messages when quality checks fail.",
        "testStrategy": "1. **Coverage Thresholds Testing**:\n   - Verify CI pipeline fails when test coverage falls below 80%\n   - Create a test case with deliberately low coverage to confirm threshold enforcement\n   - Check that coverage reports are correctly generated and displayed in CI\n\n2. **Security Scanning Testing**:\n   - Verify npm audit runs successfully in CI pipeline\n   - Test with a known vulnerable dependency (in a controlled environment) to confirm build failures\n   - Confirm audit reports are properly captured and displayed in CI logs\n\n3. **Dependabot Configuration Testing**:\n   - Verify Dependabot configuration by checking if it creates PRs for outdated dependencies\n   - Test PR creation, labeling, and assignment works as expected\n   - Confirm weekly schedule is respected\n\n4. **Pre-commit Hooks Testing**:\n   - Test each pre-commit hook individually to ensure it catches issues\n   - Verify hooks can be bypassed with appropriate Git commands when necessary\n   - Test performance impact on commit operations\n   - Ensure hooks work consistently across different developer environments\n\n5. **Biome Linting Rules Testing**:\n   - Run linter against codebase to verify rules are properly enabled\n   - Check that warnings are generated for rule violations\n   - Verify IDE integration shows warnings in real-time\n\n6. **Node.js Matrix Testing**:\n   - Verify CI runs tests against all specified Node.js versions\n   - Confirm all tests pass on each version\n   - Test with a feature that behaves differently across Node versions to ensure matrix testing catches compatibility issues\n\nDocument all testing procedures and results. Create a summary report of code quality improvements and their impact on the codebase.",
        "status": "pending",
        "dependencies": [
          20
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement Debug Mode for Linear Sync Operations",
        "description": "Create a debug mode that provides detailed logging and diagnostic information for all Linear sync operations to help troubleshoot integration issues.",
        "details": "Implement a debug flag (--debug or -d) for all Linear sync commands that enables verbose logging. Create a dedicated DebugLogger class that extends the existing logging system with methods for different verbosity levels (info, debug, trace). Log all API requests and responses with sensitive data redacted. Include timing information for performance analysis. Log state changes in the sync process with before/after snapshots. Implement colorized console output for different message types (errors in red, warnings in yellow, etc.). Create a log file option that saves all debug output to a timestamped file. Add context information to each log entry (command, operation type, task ID). Include system information in debug logs (Node version, OS, package versions). Implement a --trace flag for even more detailed logging including stack traces. Add option to export debug logs in JSON format for automated analysis. Ensure debug mode doesn't interfere with normal operation but provides maximum visibility into the sync process.",
        "testStrategy": "Test debug mode with various sync operations (create, update, status change). Verify all API calls are properly logged with sensitive data redacted. Test performance impact of debug mode to ensure it doesn't significantly slow operations. Verify log files are created correctly with proper permissions. Test with both successful operations and error scenarios to ensure comprehensive logging. Validate JSON export format for machine readability. Test in different environments (Windows, Mac, Linux) to ensure consistent logging behavior. Have team members review debug output to confirm it provides useful troubleshooting information.",
        "status": "pending",
        "dependencies": [
          3,
          16,
          20
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Create Debug Test Suite for Linear Integration",
        "description": "Develop a comprehensive test suite specifically for debugging Linear integration issues, with test cases that simulate common failure scenarios and edge cases.",
        "details": "Implement a dedicated debug test suite that complements the main testing infrastructure but focuses specifically on troubleshooting scenarios:\n\n1. Create a `LinearDebugTests` class with specialized test cases for common integration failure points:\n   - Authentication failures (invalid/expired API tokens)\n   - Network connectivity issues (timeouts, connection drops)\n   - Rate limiting scenarios\n   - Malformed API responses\n   - Concurrent operation conflicts\n   - Data synchronization edge cases\n\n2. Implement mock Linear API responses for each failure scenario:\n   - Create a `MockLinearErrorResponses` utility that returns realistic error payloads\n   - Include HTTP status codes (401, 403, 429, 500, etc.) with appropriate error messages\n   - Simulate partial success scenarios (some operations succeed, others fail)\n\n3. Create test fixtures that represent complex task hierarchies and sync states:\n   - Tasks with deep subtask nesting\n   - Tasks with conflicting status between local and remote\n   - Orphaned tasks (exist locally but not in Linear)\n   - Ghost tasks (exist in Linear but not locally)\n\n4. Implement timing and performance tests:\n   - Measure API call latency under different conditions\n   - Test bulk operations with varying payload sizes\n   - Simulate slow network conditions\n\n5. Add specific tests for the debug mode functionality:\n   - Verify debug logs contain expected diagnostic information\n   - Test log redaction of sensitive information\n   - Validate log file rotation and management\n\n6. Create a test harness that can be run in CI/CD but also manually invoked:\n   - Command: `npm run test:linear-debug`\n   - Allow targeting specific test scenarios via command line arguments\n   - Support running in verbose mode with full logging\n\n7. Document each test case with:\n   - Expected behavior\n   - Common failure patterns\n   - Troubleshooting steps for developers\n\n8. Implement a test report generator that creates detailed HTML reports of test runs with:\n   - API call sequences\n   - Request/response payloads (with sensitive data redacted)\n   - Timing information\n   - State changes",
        "testStrategy": "1. Run the full debug test suite in isolation:\n   - Verify all test cases execute without errors\n   - Confirm test coverage of all identified failure scenarios\n   - Validate that tests properly clean up after themselves\n\n2. Test the debug mode integration:\n   - Run tests with debug flag enabled and verify enhanced logging\n   - Confirm sensitive data is properly redacted in logs\n   - Validate log file creation and content\n\n3. Verify error simulation accuracy:\n   - Compare simulated error responses with actual Linear API errors\n   - Adjust mock responses to match current Linear API behavior\n   - Test error handling code paths are properly exercised\n\n4. Conduct performance validation:\n   - Measure baseline performance metrics\n   - Test with artificially degraded conditions\n   - Verify timeout and retry mechanisms function correctly\n\n5. Validate test reporting:\n   - Generate test reports and verify content accuracy\n   - Check for proper formatting and readability\n   - Ensure diagnostic information is comprehensive\n\n6. Perform integration with main test suite:\n   - Run debug tests as part of the full test pipeline\n   - Verify no conflicts with other test modules\n   - Confirm CI/CD integration works correctly\n\n7. Manual verification:\n   - Have team members run debug tests on different environments\n   - Collect feedback on test coverage and usefulness\n   - Identify any missing failure scenarios",
        "status": "pending",
        "dependencies": [
          20,
          27,
          16
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Refactor IntegrationManager Class for Improved Separation of Concerns",
        "description": "Split the monolithic IntegrationManager class into focused components: EventEmitter, IntegrationRegistry, HandlerExecutor, MiddlewarePipeline, and EventBatcher to improve maintainability and extensibility.",
        "details": "This refactoring will address the current complexity of the IntegrationManager class by breaking it down into specialized components:\n\n1. **Analysis Phase**:\n   - Review the current 1375+ line IntegrationManager class\n   - Document all responsibilities and dependencies\n   - Identify natural boundaries between concerns\n   - Create class diagrams for the new architecture\n\n2. **Component Design**:\n   - **EventEmitter**: Responsible for event registration, emission, and subscription\n     - Methods: `on(eventName, handler)`, `emit(eventName, data)`, `off(eventName, handler)`\n     - Support for synchronous and asynchronous event handling\n     - Implement proper error boundaries for event handlers\n   \n   - **IntegrationRegistry**: Manages integration registration and discovery\n     - Methods: `register(integration)`, `getIntegration(name)`, `listIntegrations()`, `isEnabled(name)`\n     - Validation of integration interfaces\n     - Support for enabling/disabling integrations\n   \n   - **HandlerExecutor**: Handles execution of integration callbacks with resilience patterns\n     - Implements retry logic with exponential backoff\n     - Circuit breaker pattern to prevent cascading failures\n     - Timeout handling for long-running operations\n     - Error isolation between handlers\n   \n   - **MiddlewarePipeline**: Processes events through configurable middleware chains\n     - Pre-processing and post-processing hooks\n     - Filtering and transformation capabilities\n     - Ability to short-circuit event propagation\n   \n   - **EventBatcher**: Handles batching of events for efficient processing\n     - Configurable batch sizes and timeouts\n     - Debouncing of rapidly firing events\n     - Priority-based processing\n\n3. **Implementation Strategy**:\n   - Create new classes with well-defined interfaces\n   - Implement a facade pattern to maintain backward compatibility\n   - Gradually migrate functionality from IntegrationManager to new components\n   - Update all references to use the new components\n   - Ensure proper dependency injection between components\n\n4. **Migration Approach**:\n   - Create new classes alongside existing IntegrationManager\n   - Implement one component at a time, starting with EventEmitter\n   - Update IntegrationManager to use new components internally\n   - Once all functionality is migrated, convert IntegrationManager to a facade\n\n5. **Documentation**:\n   - Update architecture documentation with new component diagrams\n   - Document interfaces for each component\n   - Provide migration guide for plugin developers\n   - Add code examples for common integration patterns",
        "testStrategy": "The refactoring will be tested through a comprehensive approach:\n\n1. **Unit Tests for Each Component**:\n   - **EventEmitter**:\n     - Test event registration, emission, and subscription\n     - Verify error boundaries contain failures\n     - Test asynchronous event handling\n     - Measure performance with many subscribers\n   \n   - **IntegrationRegistry**:\n     - Test registration of valid and invalid integrations\n     - Verify retrieval and listing functionality\n     - Test enabling/disabling integrations\n   \n   - **HandlerExecutor**:\n     - Test retry logic with simulated failures\n     - Verify circuit breaker functionality\n     - Test timeout handling\n     - Measure performance under load\n   \n   - **MiddlewarePipeline**:\n     - Test middleware execution order\n     - Verify transformation capabilities\n     - Test short-circuit functionality\n   \n   - **EventBatcher**:\n     - Test batching with various configurations\n     - Verify debouncing functionality\n     - Test priority-based processing\n\n2. **Integration Tests**:\n   - Verify all components work together correctly\n   - Test with existing integrations (Linear, Git)\n   - Ensure backward compatibility with existing code\n\n3. **Regression Testing**:\n   - Run all existing tests to ensure no functionality is broken\n   - Test all commands that use the IntegrationManager\n   - Verify event emission and handling works identically\n\n4. **Performance Testing**:\n   - Compare performance before and after refactoring\n   - Test with large numbers of events and integrations\n   - Measure memory usage and execution time\n\n5. **Compatibility Testing**:\n   - Verify existing plugins continue to work\n   - Test with different Node.js versions\n   - Ensure configuration options are respected",
        "status": "pending",
        "dependencies": [
          3,
          19
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Refactor handleEvent Method in IntegrationManager",
        "description": "Split the complex 230+ line handleEvent method into smaller, focused private methods to improve testability and maintainability.",
        "details": "This task involves breaking down the monolithic handleEvent method in the IntegrationManager class into smaller, more focused methods with clear responsibilities:\n\n1. **Analysis Phase**:\n   - Review the current handleEvent method implementation\n   - Document the flow and responsibilities within the method\n   - Identify clear boundaries for extraction into separate methods\n   - Create a plan for refactoring that maintains the same behavior\n\n2. **Implementation Phase**:\n   - Extract the following private methods:\n     - `_validateEventForHandling()`: Responsible for validating event payload structure, required fields, and data types\n     - `_processMiddleware()`: Handles the execution of middleware functions in the correct order with proper error handling\n     - `_findAndExecuteHandlers()`: Locates appropriate event handlers, executes them with retry logic and circuit breaker patterns\n     - `_collectHandlerResults()`: Gathers results from all handlers, formats them consistently, and prepares the final response\n\n3. **Code Quality Improvements**:\n   - Add JSDoc comments to each new method explaining purpose, parameters, and return values\n   - Implement proper error handling in each extracted method\n   - Ensure consistent logging throughout the refactored methods\n   - Update any existing tests to work with the new structure\n\n4. **Considerations**:\n   - Maintain backward compatibility - the public API should not change\n   - Ensure the refactored code handles all edge cases from the original implementation\n   - Look for opportunities to improve error handling during the refactoring\n   - Consider adding additional unit tests for the new private methods\n   - Ensure the refactoring doesn't negatively impact performance",
        "testStrategy": "The refactoring will be tested through a comprehensive approach:\n\n1. **Regression Testing**:\n   - Run all existing integration tests to ensure the refactored code maintains the same behavior\n   - Verify that all event types continue to be processed correctly\n   - Confirm that error handling works as expected for various failure scenarios\n\n2. **Unit Tests for New Methods**:\n   - Create dedicated unit tests for each extracted method:\n     - `_validateEventForHandling()`: Test with valid and invalid payloads\n     - `_processMiddleware()`: Test with various middleware configurations and error scenarios\n     - `_findAndExecuteHandlers()`: Test handler discovery, retry logic, and circuit breaker functionality\n     - `_collectHandlerResults()`: Test result aggregation with different handler outputs\n\n3. **Edge Case Testing**:\n   - Test with empty event payloads\n   - Test with malformed event data\n   - Test with missing handlers\n   - Test with failing middleware\n   - Test with handlers that timeout or throw exceptions\n\n4. **Performance Testing**:\n   - Compare performance metrics before and after refactoring\n   - Ensure the refactoring doesn't introduce significant overhead\n\n5. **Code Review**:\n   - Conduct a thorough code review to ensure the refactoring follows best practices\n   - Verify that all edge cases from the original implementation are handled",
        "status": "pending",
        "dependencies": [
          29
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Refactor HealthMonitor Class Following SOLID Principles",
        "description": "Split the monolithic 800+ line HealthMonitor class into focused components: HealthChecker, MetricsCollector, AlertManager, and a coordinating HealthMonitor class to improve maintainability.",
        "details": "This task involves refactoring the HealthMonitor class to follow SOLID principles by breaking it down into specialized components:\n\n1. **Analysis Phase**:\n   - Review the current 800+ line HealthMonitor class implementation\n   - Document all responsibilities and dependencies\n   - Identify clear boundaries between health checks, metrics collection, and alerting\n   - Create class diagrams for the new architecture\n\n2. **Component Design**:\n   - **HealthChecker**: Responsible for running health checks\n     - Methods for registering health checks\n     - Executing individual and batch health checks\n     - Storing and retrieving health check results\n     - Supporting both synchronous and asynchronous health checks\n\n   - **MetricsCollector**: Responsible for metrics collection\n     - Methods for registering metrics\n     - Collecting metrics from various sources\n     - Processing and aggregating metrics\n     - Providing interfaces for metrics retrieval\n\n   - **AlertManager**: Responsible for alert management\n     - Alert rule configuration\n     - Alert triggering based on health checks and metrics\n     - Alert notification dispatch\n     - Alert status tracking and history\n\n   - **HealthMonitor**: Coordinates the above components\n     - Initializes and manages component lifecycle\n     - Provides a simplified facade for common operations\n     - Handles cross-cutting concerns like logging and error handling\n     - Maintains backward compatibility with existing API\n\n3. **Implementation Phase**:\n   - Create interface definitions for each component\n   - Implement each component with proper unit tests\n   - Refactor existing code to use the new components\n   - Update dependency injection to wire up the new components\n   - Ensure backward compatibility with existing API consumers\n\n4. **Documentation**:\n   - Update class documentation to reflect new architecture\n   - Create sequence diagrams for common operations\n   - Document migration path for code currently using HealthMonitor\n\n5. **Performance Considerations**:\n   - Ensure refactoring doesn't introduce performance regressions\n   - Consider caching strategies for health check results\n   - Optimize cross-component communication",
        "testStrategy": "The refactoring will be tested through a comprehensive approach:\n\n1. **Unit Tests for Each Component**:\n   - **HealthChecker**:\n     - Test health check registration and execution\n     - Verify error handling during health checks\n     - Test asynchronous health check behavior\n     - Validate health check result storage and retrieval\n\n   - **MetricsCollector**:\n     - Test metrics registration and collection\n     - Verify metrics aggregation functions\n     - Test performance of metrics collection\n     - Validate metrics retrieval interfaces\n\n   - **AlertManager**:\n     - Test alert rule configuration\n     - Verify alert triggering based on conditions\n     - Test notification dispatch to various channels\n     - Validate alert history tracking\n\n   - **HealthMonitor**:\n     - Test coordination between components\n     - Verify backward compatibility with existing API\n     - Test error propagation and handling\n     - Validate lifecycle management\n\n2. **Integration Tests**:\n   - Test end-to-end scenarios using all components\n   - Verify system behavior matches pre-refactoring behavior\n   - Test boundary conditions and edge cases\n   - Validate performance characteristics\n\n3. **Regression Testing**:\n   - Run existing test suite against refactored code\n   - Compare performance metrics before and after refactoring\n   - Verify all existing functionality continues to work\n   - Ensure no new bugs are introduced\n\n4. **Code Quality Metrics**:\n   - Verify reduction in class size and complexity\n   - Confirm improved test coverage\n   - Validate adherence to SOLID principles\n   - Check for proper encapsulation and information hiding",
        "status": "pending",
        "dependencies": [
          26,
          29,
          30
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Optimize EventQueue pushBatch Method for Performance",
        "description": "Refactor the pushBatch method in EventQueue to improve performance when handling large batches of events by reducing redundant processing checks.",
        "details": "This task involves optimizing the EventQueue's pushBatch method which currently has performance issues when handling large batches:\n\n1. **Analysis Phase**:\n   - Review the current implementation of pushBatch method which sequentially calls push() for each item\n   - Identify the performance bottlenecks, particularly the redundant processing checks triggered for each item\n   - Profile the current implementation with various batch sizes to establish a baseline\n\n2. **Implementation Phase**:\n   - Refactor the pushBatch method to use one of two approaches:\n     a. **Batch Processing Approach**: Modify the implementation to collect all items first, then process them as a single batch operation\n        ```typescript\n        // Current implementation (simplified)\n        pushBatch(events: Event[]): void {\n          for (const event of events) {\n            this.push(event); // Triggers processing checks for each item\n          }\n        }\n        \n        // Proposed batch implementation\n        pushBatch(events: Event[]): void {\n          if (events.length === 0) return;\n          \n          // Add all events to the queue at once\n          this.queue.push(...events);\n          \n          // Trigger processing check only once after all items are added\n          this.checkProcessing();\n        }\n        ```\n     \n     b. **Concurrent Processing Approach**: Use Promise.all to push items concurrently\n        ```typescript\n        // Concurrent implementation\n        async pushBatch(events: Event[]): Promise<void> {\n          if (events.length === 0) return;\n          \n          await Promise.all(events.map(event => {\n            // Add to queue without triggering processing\n            this.queue.push(event);\n            return Promise.resolve();\n          }));\n          \n          // Trigger processing check only once\n          this.checkProcessing();\n        }\n        ```\n\n3. **Optimization Considerations**:\n   - Ensure the optimized implementation maintains the same event ordering guarantees\n   - Add batch size thresholds to dynamically choose between sequential and batch processing based on batch size\n   - Consider implementing a chunking mechanism for extremely large batches to prevent memory issues\n   - Update any related documentation to reflect the new behavior\n   - Ensure backward compatibility with existing code that relies on pushBatch\n\n4. **Performance Monitoring**:\n   - Add performance metrics to measure the improvement (e.g., time to process batches of different sizes)\n   - Consider adding logging for large batch operations to aid in future performance analysis",
        "testStrategy": "The optimization will be tested through a comprehensive approach:\n\n1. **Unit Tests**:\n   - Create unit tests with various batch sizes (small, medium, large) to verify correct behavior\n   - Test edge cases: empty batches, single-item batches, and very large batches (1000+ items)\n   - Verify that events are still processed in the correct order after optimization\n   - Test that event handlers are still called correctly for all events\n\n2. **Performance Testing**:\n   - Benchmark the optimized implementation against the original implementation\n   - Measure and compare:\n     - Total processing time for batches of 10, 100, 1000, and 10000 events\n     - Memory usage during batch processing\n     - CPU utilization during batch processing\n   - Create a performance test that simulates real-world usage patterns\n   - Verify performance improvements meet expectations (aim for at least 50% improvement for large batches)\n\n3. **Integration Testing**:\n   - Test the optimized EventQueue with actual components that depend on it\n   - Verify that all dependent systems continue to function correctly\n   - Test with realistic event payloads from production scenarios\n\n4. **Regression Testing**:\n   - Run the existing test suite to ensure no regressions were introduced\n   - Verify that all event processing logic continues to work as expected\n\n5. **Documentation Verification**:\n   - Ensure any API documentation is updated to reflect changes in behavior or performance characteristics",
        "status": "pending",
        "dependencies": [
          18,
          29,
          31
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Implement Bulk Sync Command for Existing Tasks to Linear",
        "description": "Create a command to synchronize all existing TaskMaster tasks to Linear issues, handling tasks created before Linear integration setup and updating tasks.json with Linear issue IDs and URLs.",
        "details": "1. Create a new command 'bulk-sync' in the CLI interface.\n2. Implement a function to fetch all existing tasks from tasks.json.\n3. For each task without a Linear ID:\n   a. Create a new Linear issue using the Linear SDK.\n   b. Handle rate limiting by implementing exponential backoff.\n   c. Store the returned Linear issue ID and URL in the task object.\n4. Update tasks.json with the new Linear information.\n5. Implement error handling:\n   a. Log errors for failed syncs.\n   b. Continue processing other tasks if one fails.\n   c. Provide a summary of successful and failed syncs.\n6. Add a dry-run option to preview changes without making API calls.\n7. Implement batching to process tasks in groups (e.g., 50 at a time) to manage memory usage for large projects.\n8. Add a progress bar or spinner to indicate sync progress.\n9. Ensure idempotency - if the command is run multiple times, it should not create duplicate Linear issues.\n10. Add options to filter tasks for sync (e.g., by status, priority, or date range).\n11. Implement a confirmation prompt before starting the bulk sync operation.\n12. Add verbose logging option for debugging.\n13. Handle subtasks by ensuring parent tasks are synced first and maintaining hierarchy in Linear.\n14. Update the IntegrationManager to emit 'tasksBulkSynced' event after completion.\n15. Document the new command in the help system and user documentation.",
        "testStrategy": "1. Create a test project with a mix of tasks (with and without Linear IDs).\n2. Run the bulk-sync command and verify:\n   a. All tasks without Linear IDs are synced.\n   b. Existing Linear IDs are not changed.\n   c. tasks.json is correctly updated with new Linear IDs and URLs.\n3. Test error handling by intentionally causing failures (e.g., invalid API key) and verify graceful handling.\n4. Verify rate limiting handling by monitoring API calls and ensuring backoff is implemented.\n5. Test the dry-run option and confirm no actual changes are made.\n6. Verify batching works correctly with a large number of tasks.\n7. Test idempotency by running the command multiple times and ensuring no duplicates are created.\n8. Verify subtask hierarchy is maintained in Linear after sync.\n9. Test task filtering options and confirm only specified tasks are synced.\n10. Verify the confirmation prompt works and prevents accidental syncs.\n11. Test verbose logging and ensure it provides useful debugging information.\n12. Verify the 'tasksBulkSynced' event is emitted correctly.\n13. Test performance with varying project sizes to ensure reasonable sync times.\n14. Verify all changes are reflected accurately in both TaskMaster and Linear after sync.",
        "status": "pending",
        "dependencies": [
          3,
          5,
          8,
          16,
          17,
          20
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Design bulk sync data structure",
            "description": "Create a data structure to efficiently handle the bulk sync operation between TaskMaster and Linear",
            "dependencies": [],
            "details": "Define classes or interfaces to represent TaskMaster and Linear tasks, and create a mapping structure to track the sync status of each task",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Implement Linear API integration",
            "description": "Develop functions to interact with the Linear API for bulk task creation and updates",
            "dependencies": [
              1
            ],
            "details": "Create methods for authentication, task creation, and task updates using Linear's API endpoints",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Develop bulk sync logic",
            "description": "Create the main logic for syncing TaskMaster tasks to Linear in bulk",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement the core algorithm to efficiently process and sync multiple tasks, considering rate limits and optimizing for performance",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Implement error handling and retries",
            "description": "Add robust error handling and retry mechanisms for sync failures",
            "dependencies": [
              3
            ],
            "details": "Implement try-catch blocks, custom error types, and a retry system with exponential backoff for failed sync attempts",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Add progress tracking and reporting",
            "description": "Implement a system to track and report sync progress",
            "dependencies": [
              3
            ],
            "details": "Create a progress bar or logging system to display real-time sync status, including total tasks, completed tasks, and any errors encountered",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Perform testing and optimization",
            "description": "Conduct thorough testing and optimize the bulk sync command for performance",
            "dependencies": [
              4,
              5
            ],
            "details": "Write unit and integration tests, perform load testing with large datasets, and optimize the sync process for speed and resource usage",
            "status": "pending"
          }
        ]
      },
      {
        "id": 34,
        "title": "Implement Real Bidirectional Status Synchronization",
        "description": "Replace the mock status sync implementation with actual Linear API calls to update issue states when TaskMaster task status changes, implementing one-way synchronization from TaskMaster to Linear.",
        "status": "pending",
        "dependencies": [
          7,
          18,
          20,
          27
        ],
        "priority": "medium",
        "details": "This task implements one-way status synchronization from TaskMaster to Linear. TaskMaster is the source of truth, and we will only push status changes from TaskMaster to Linear (no reverse sync).\n\n1. Update LinearIntegration class to include real API calls:\n   - Modify onTaskStatusChanged to use linearClient.updateIssue() with the correct stateId\n   - Implement a status mapping function to convert TaskMaster statuses (pending, in-progress, done, review, cancelled, deferred) to Linear state IDs\n   - Handle special cases like 'deferred' and 'cancelled' with appropriate Linear actions\n\n2. Status mapping implementation:\n   - Create a configurable mapping between TaskMaster statuses and Linear workflow states\n   - Implement a lookup function that returns the correct Linear stateId for each TaskMaster status\n   - Handle cases where a Linear project might have custom workflow states\n\n3. Handle edge cases:\n   - Add error handling for API failures or mapping mismatches\n   - Implement a retry mechanism for failed synchronizations\n   - Handle cases where a Linear issue might not exist for a TaskMaster task\n\n4. Update configuration:\n   - Add Linear workflow state IDs to the config file for mapping\n   - Ensure API credentials are properly configured\n\n5. Optimize performance:\n   - Implement caching for Linear state IDs to reduce API calls\n   - Use bulk update operations where possible for multiple status changes\n\n6. Logging and monitoring:\n   - Add detailed logging for all sync operations\n   - Implement metrics tracking for sync successes, failures, and latency\n\n7. Update CLI commands:\n   - Modify existing status update commands to use the new one-way sync\n   - Add a command to manually trigger a status sync from TaskMaster to Linear for all tasks",
        "testStrategy": "1. Unit Tests:\n   - Test status mapping functions from TaskMaster to Linear\n   - Mock Linear API calls and verify correct parameters are sent\n   - Verify error handling and retry logic\n\n2. Integration Tests:\n   - Set up a Linear sandbox environment for testing\n   - Perform status changes in TaskMaster and verify Linear state updates\n   - Test all possible TaskMaster status transitions, including edge cases\n   - Verify that changes in Linear do NOT affect TaskMaster (one-way sync only)\n\n3. End-to-End Tests:\n   - Create a test workflow that changes statuses in TaskMaster\n   - Verify Linear issues are updated correctly\n   - Test performance with a large number of tasks/issues\n   - Confirm that status changes in Linear are not synchronized back to TaskMaster\n\n4. Error and Edge Case Testing:\n   - Simulate API failures and verify graceful handling\n   - Test with missing or invalid Linear issue IDs\n   - Verify handling of unmapped or custom statuses\n\n5. Security Testing:\n   - Verify proper handling of API keys and secrets\n\n6. Performance Testing:\n   - Measure sync latency for individual and bulk updates\n   - Verify caching mechanisms are working as expected\n\n7. CLI Testing:\n   - Test all updated CLI commands for status changes\n   - Verify manual sync command works correctly for pushing TaskMaster statuses to Linear\n\n8. Regression Testing:\n   - Ensure existing functionality (e.g., task creation, updates) still works with the new sync implementation",
        "subtasks": [
          {
            "id": 1,
            "title": "Design TaskMaster-to-Linear sync architecture",
            "description": "Create a high-level design for the one-way synchronization process from TaskMaster to Linear",
            "dependencies": [],
            "details": "Include data flow diagrams, API integration points, and synchronization frequency considerations",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Implement TaskMaster change detection mechanism",
            "description": "Develop a system to detect and queue changes in TaskMaster for synchronization to Linear",
            "dependencies": [
              1
            ],
            "details": "Use database triggers or application-level event tracking to capture task updates, creations, and deletions",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Create Linear API integration module",
            "description": "Develop a module to interact with Linear's API for creating and updating issues",
            "dependencies": [
              1
            ],
            "details": "Implement functions for authentication, CRUD operations, and error handling with Linear's API",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Implement data mapping logic",
            "description": "Create functions to map TaskMaster data structures to Linear issue format",
            "dependencies": [
              2,
              3
            ],
            "details": "Define mappings for task fields, custom fields, and metadata between TaskMaster and Linear",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Develop synchronization worker",
            "description": "Create a background worker to process the queue of TaskMaster changes and sync them to Linear",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement retry logic, rate limiting, and logging for the synchronization process",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Implement error handling and logging",
            "description": "Create a robust error handling system and logging mechanism for the sync process",
            "dependencies": [
              5
            ],
            "details": "Log sync attempts, successes, and failures. Implement alerts for critical errors and sync discrepancies",
            "status": "pending"
          },
          {
            "id": 7,
            "title": "Develop admin interface for sync management",
            "description": "Create an interface for administrators to monitor and manage the synchronization process",
            "dependencies": [
              5,
              6
            ],
            "details": "Include features like manual sync triggering, sync status overview, and error log viewing",
            "status": "pending"
          }
        ]
      },
      {
        "id": 35,
        "title": "Implement Comprehensive Subtask Synchronization between TaskMaster and Linear",
        "description": "Develop one-way synchronization for subtasks from TaskMaster to Linear, including options for syncing as sub-issues, comments, or task descriptions. TaskMaster is the source of truth with changes only flowing from TaskMaster to Linear.",
        "status": "pending",
        "dependencies": [
          4,
          8,
          16
        ],
        "priority": "medium",
        "details": "1. Extend the LinearIntegration module to handle one-way subtask synchronization from TaskMaster to Linear:\n   - Modify onTaskCreated and onTaskUpdated handlers to detect subtasks in TaskMaster.\n   - Implement logic to determine sync method based on configuration (sub-issue, comment, or description).\n   - Ensure all data flows only from TaskMaster to Linear, with TaskMaster as the source of truth.\n\n2. Sub-issue synchronization:\n   - When creating a subtask in TaskMaster, use Linear's createIssue API with parentId parameter.\n   - Update existing tasks to subtasks using updateIssue with new parentId.\n   - Implement batch creation for multiple subtasks from TaskMaster.\n\n3. Comment synchronization:\n   - Create a new comment on the parent Linear issue for each TaskMaster subtask.\n   - Use createComment API to add subtask details as a structured comment.\n   - Implement comment updates when subtask details change in TaskMaster.\n\n4. Description synchronization:\n   - Append TaskMaster subtask information to the parent task's description in Linear.\n   - Use updateIssue API to modify the description with subtask details.\n   - Implement intelligent merging to avoid duplicating subtask info.\n\n5. One-way sync from TaskMaster to Linear:\n   - Implement handlers for TaskMaster subtask changes to push to Linear.\n   - Create functions to update Linear when subtasks are created, updated, or deleted in TaskMaster.\n   - Ensure changes in TaskMaster are properly reflected in Linear based on the chosen sync method.\n   - Do not implement any reverse synchronization from Linear to TaskMaster.\n\n6. Status tracking:\n   - Map subtask statuses from TaskMaster to Linear.\n   - Implement logic to update parent task status in Linear based on subtask completion in TaskMaster.\n\n7. Performance optimization:\n   - Implement batching for multiple subtask updates from TaskMaster to Linear.\n   - Use efficient querying to minimize API calls.\n\n8. Error handling and logging:\n   - Extend error handling to cover subtask-specific scenarios.\n   - Implement detailed logging for subtask sync operations.\n   - Add specific error handling for one-way sync failures.\n\n9. Configuration:\n   - Add subtask sync configuration options to TaskMaster settings.\n   - Allow users to choose between sync methods (sub-issue, comment, description).\n   - Clearly indicate in the UI that sync is one-way only (TaskMaster to Linear).\n\n10. CLI updates:\n    - Extend CLI commands to support subtask-specific operations.\n    - Add options to force-sync subtasks or change sync method.\n    - Include clear documentation that changes in Linear will not sync back to TaskMaster.",
        "testStrategy": "1. Unit tests:\n   - Mock Linear API responses for subtask operations.\n   - Test subtask detection logic in onTaskCreated and onTaskUpdated.\n   - Verify correct API calls for each sync method (sub-issue, comment, description).\n   - Verify no reverse sync logic exists in the codebase.\n\n2. Integration tests:\n   - Create a test Linear workspace with various project structures.\n   - Test creation of subtasks in TaskMaster and verify correct representation in Linear.\n   - Test bulk creation and updates of subtasks from TaskMaster to Linear.\n   - Verify changes made in Linear do not affect TaskMaster data.\n\n3. Sync method tests:\n   - Verify correct creation of sub-issues, comments, and description updates in Linear.\n   - Test switching between sync methods and ensure data integrity.\n\n4. One-way sync tests:\n   - Verify changes in TaskMaster subtasks are correctly reflected in Linear.\n   - Test various update scenarios (creation, modification, deletion) from TaskMaster.\n   - Verify that changes made directly in Linear do not trigger any sync operations.\n\n5. Status and dependency tests:\n   - Verify subtask status changes in TaskMaster correctly update task status in Linear.\n   - Test complex dependency scenarios with multiple levels of subtasks.\n\n6. Performance tests:\n   - Measure sync time for large numbers of subtasks.\n   - Verify batching optimizations reduce API calls.\n\n7. Error handling and recovery tests:\n   - Simulate network failures during subtask sync.\n   - Test incomplete syncs and verify recovery mechanism.\n\n8. Configuration tests:\n   - Verify subtask sync behavior changes correctly with different configuration options.\n   - Test that one-way sync settings are properly enforced.\n\n9. CLI tests:\n   - Test new CLI commands related to subtask management and sync.\n   - Verify CLI commands respect the one-way sync paradigm.\n\n10. User acceptance testing:\n    - Conduct UAT with team members to verify intuitive subtask management from TaskMaster to Linear.\n    - Ensure users understand the one-way nature of the synchronization.",
        "subtasks": [
          {
            "id": 1,
            "title": "Design TaskMaster-to-Linear Sync Architecture",
            "description": "Create a high-level design for the one-way synchronization process from TaskMaster to Linear",
            "dependencies": [],
            "details": "Include data flow diagrams, API integration points, and synchronization triggers",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Implement TaskMaster Subtask Change Detection",
            "description": "Develop a mechanism to detect changes in TaskMaster subtasks that need to be synced to Linear",
            "dependencies": [
              1
            ],
            "details": "Use webhooks or polling to identify new, updated, or deleted subtasks in TaskMaster",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Create Linear API Integration Module",
            "description": "Develop a module to interact with Linear's API for creating and updating subtasks",
            "dependencies": [
              1
            ],
            "details": "Implement functions for authentication, CRUD operations, and error handling",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Implement Subtask Hierarchy Mapping",
            "description": "Create a system to map TaskMaster's subtask hierarchy to Linear's structure",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Develop algorithms to maintain parent-child relationships and handle nested subtasks",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Develop Sync Conflict Resolution",
            "description": "Implement logic to handle potential conflicts during the synchronization process",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create rules for resolving conflicts in subtask attributes, priorities, and relationships",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Implement Sync Logging and Error Handling",
            "description": "Create a robust logging and error handling system for the synchronization process",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Log all sync actions, errors, and implement retry mechanisms for failed operations",
            "status": "pending"
          },
          {
            "id": 7,
            "title": "Perform Integration Testing and Optimization",
            "description": "Conduct thorough testing of the TaskMaster-to-Linear synchronization process and optimize performance",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Create test scenarios, perform load testing, and optimize sync algorithms for efficiency",
            "status": "pending"
          }
        ]
      },
      {
        "id": 36,
        "title": "Implement Git Branch Integration with Linear Issues",
        "description": "Enhance TaskMaster to automatically create and store Git branch names when tasks are synced to Linear, using patterns like 'task-{taskId}-{slugified-title}' or 'linear-{issueNumber}-{slug}'. Store both the Linear issue ID and the branch name in task metadata.",
        "details": "1. Update the LinearIntegration class to include branch name generation:\n   - Create a new method generateBranchName(task) that takes a task object and returns a branch name\n   - Implement slugify function to convert task titles into URL-friendly strings\n   - Use the pattern 'task-{taskId}-{slugified-title}' for TaskMaster-originated tasks\n   - Use 'linear-{issueNumber}-{slug}' for tasks created in Linear and synced to TaskMaster\n\n2. Modify the sync process to generate and store branch names:\n   - In the createLinearIssue method, after successfully creating the Linear issue:\n     - Generate the branch name using the new generateBranchName method\n     - Update the task in tasks.json with the new branch name and Linear issue ID\n   - In the syncExistingTask method, add similar logic for tasks that already exist in Linear\n\n3. Update the Task class and tasks.json structure:\n   - Add 'branchName' and 'linearIssueId' properties to the Task class\n   - Modify the toJSON and fromJSON methods to include these new properties\n   - Update the tasks.json file structure to store these new fields\n\n4. Implement a command to generate branch names for existing tasks:\n   - Create a new CLI command 'generate-branches' that processes all tasks\n   - For each task with a Linear issue ID but no branch name, generate and store the branch name\n\n5. Add utility functions for developers:\n   - Implement a 'get-branch' command that takes a task ID and outputs the associated branch name\n   - Create a 'checkout' command that creates and checks out the branch for a given task ID\n\n6. Update relevant commands (like 'task create', 'task edit', 'sync') to handle the new properties\n\n7. Implement error handling and validation:\n   - Ensure branch names are unique across the project\n   - Handle cases where Linear issue numbers might change (e.g., if an issue is moved between projects)\n\n8. Update documentation to reflect new functionality and commands",
        "testStrategy": "1. Unit Tests:\n   - Test generateBranchName method with various task titles and IDs\n   - Verify slugify function correctly handles special characters and spaces\n   - Test Task class serialization and deserialization with new properties\n\n2. Integration Tests:\n   - Test full sync process and verify branch names are correctly generated and stored\n   - Verify 'generate-branches' command works for existing tasks\n   - Test 'get-branch' and 'checkout' commands with various scenarios (existing/non-existing tasks)\n\n3. Edge Case Testing:\n   - Test handling of tasks with very long titles\n   - Verify behavior when syncing a large number of tasks simultaneously\n   - Test with special characters in task titles (including non-ASCII characters)\n\n4. Regression Testing:\n   - Ensure existing sync functionality still works correctly with the new changes\n   - Verify that tasks.json file remains valid and backwards-compatible\n\n5. Manual Testing:\n   - Perform end-to-end testing of creating a task, syncing to Linear, and using the branch name\n   - Test the workflow of creating a task in Linear and syncing it back to TaskMaster\n\n6. Performance Testing:\n   - Measure the impact on sync performance with branch name generation\n   - Test with a large number of tasks to ensure efficient handling\n\n7. Error Handling:\n   - Test error scenarios such as network failures during sync\n   - Verify proper error messages when trying to get branch names for non-existent tasks\n\n8. Git Integration Testing:\n   - Verify that generated branch names are valid and can be created in Git\n   - Test the 'checkout' command in a real Git repository",
        "status": "pending",
        "dependencies": [
          4,
          13,
          18,
          20
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Design branch naming convention",
            "description": "Create a standardized format for generating Git branch names based on Linear issue details",
            "dependencies": [],
            "details": "Define a clear and consistent naming convention that incorporates relevant issue information (e.g., issue number, title) while ensuring compatibility with Git branch naming rules",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Implement branch name generation function",
            "description": "Develop a function to automatically generate Git branch names based on Linear issue data",
            "dependencies": [
              1
            ],
            "details": "Create a reusable function that takes Linear issue details as input and returns a properly formatted branch name according to the defined convention",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Add branch metadata storage to Linear tasks",
            "description": "Extend the Linear task data model to include fields for storing Git branch information",
            "dependencies": [],
            "details": "Modify the Linear task schema to add fields for branch name, creation date, and any other relevant Git branch metadata",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Implement Git branch creation and linking",
            "description": "Develop functionality to create a Git branch and associate it with a Linear issue",
            "dependencies": [
              2,
              3
            ],
            "details": "Create a process that generates a branch name, creates the branch in the Git repository, and updates the Linear issue with the branch metadata",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Add user interface for branch management",
            "description": "Design and implement UI components for viewing and managing Git branches associated with Linear issues",
            "dependencies": [
              4
            ],
            "details": "Create UI elements to display branch information, allow manual branch creation, and provide options for branch management within the Linear interface",
            "status": "pending"
          }
        ]
      },
      {
        "id": 38,
        "title": "Enhance Label Synchronization with Linear Integration",
        "description": "Update the existing label synchronization functionality to create missing labels in Linear and store the returned Linear label IDs in the TaskMaster configuration for later use when applying labels to synced issues.",
        "details": "1. Modify the existing label synchronization function to check for missing labels in Linear:\n   - Fetch all labels from Linear using the SDK\n   - Compare against labels defined in TaskMaster configuration\n   - Identify labels that exist in TaskMaster but not in Linear\n\n2. Implement label creation in Linear:\n   - For each missing label, use linearClient.createLabel() to create the label in Linear\n   - Ensure proper error handling for API failures or rate limiting\n\n3. Update TaskMaster configuration with Linear label IDs:\n   - Modify the config.json structure to include a 'linearLabels' section\n   - Store each label with its name and corresponding Linear ID\n   - Example structure:\n     ```json\n     \"linearLabels\": {\n       \"bug\": \"lin_abc123\",\n       \"feature\": \"lin_def456\"\n     }\n     ```\n\n4. Modify the existing label application logic:\n   - When applying labels to synced issues, use the stored Linear label IDs instead of label names\n   - Update linearClient.updateIssue() calls to use the correct label ID format\n\n5. Implement a periodic label sync function:\n   - Create a function that can be called to refresh the label mapping\n   - This should be triggered on startup and periodically during long-running sessions\n\n6. Update the setup wizard (Task 5) to include initial label synchronization:\n   - After configuring label preferences, perform an initial sync of labels\n   - Store the results in the configuration before completing the setup\n\n7. Error Handling and Logging:\n   - Implement robust error handling for all Linear API interactions\n   - Log label creation successes and failures\n   - Provide user feedback for sync operations\n\n8. Performance Considerations:\n   - Implement batching for label creation if creating multiple labels\n   - Consider caching label data to reduce API calls\n\n9. Update documentation to reflect new label handling processes",
        "testStrategy": "1. Unit Tests:\n   - Mock Linear SDK responses for label fetching and creation\n   - Test label comparison logic to correctly identify missing labels\n   - Verify correct updating of config.json with Linear label IDs\n   - Test error handling for various API failure scenarios\n\n2. Integration Tests:\n   - Set up a test Linear workspace with a known set of labels\n   - Run the label sync process and verify:\n     a) Missing labels are created in Linear\n     b) Existing labels are correctly mapped\n     c) Config file is updated with correct Linear label IDs\n   - Attempt to sync with invalid or duplicate labels and verify error handling\n\n3. End-to-End Tests:\n   - Perform a full setup process including label sync\n   - Create tasks with various labels and verify they sync correctly to Linear\n   - Modify labels in Linear and TaskMaster, then re-sync to test bidirectional updates\n\n4. Performance Testing:\n   - Test with a large number of labels to ensure efficient handling\n   - Verify caching mechanisms work as expected\n\n5. User Acceptance Testing:\n   - Have team members perform label sync operations\n   - Verify that the process is intuitive and provides clear feedback\n\n6. Edge Case Testing:\n   - Test with special characters in label names\n   - Verify behavior when Linear has labels not present in TaskMaster\n   - Test with maximum allowed labels in Linear\n\n7. Regression Testing:\n   - Ensure existing label functionality still works as expected\n   - Verify that other parts of the Linear integration are not affected by these changes",
        "status": "pending",
        "dependencies": [
          5,
          10,
          "6"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze current label synchronization process",
            "description": "Review the existing label synchronization implementation and identify areas for improvement",
            "dependencies": [],
            "details": "Examine the current code for label synchronization, document the flow, and list any limitations or issues",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Implement missing label creation in Linear",
            "description": "Develop functionality to create labels in Linear that exist in the local system but not in Linear",
            "dependencies": [
              1
            ],
            "details": "Write code to compare local labels with Linear labels, identify missing ones, and use Linear API to create them",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Store Linear label IDs in local system",
            "description": "Modify the local system to store and associate Linear label IDs with corresponding local labels",
            "dependencies": [
              2
            ],
            "details": "Update database schema or data structure to include Linear label IDs, and implement logic to store and retrieve these IDs",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Implement bidirectional label synchronization",
            "description": "Develop functionality to keep labels in sync between the local system and Linear in both directions",
            "dependencies": [
              2,
              3
            ],
            "details": "Create methods to detect label changes in both systems and propagate updates accordingly, handling conflicts if they arise",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Test and validate enhanced label synchronization",
            "description": "Create and execute test cases to ensure the enhanced label synchronization works correctly",
            "dependencies": [
              4
            ],
            "details": "Develop unit tests and integration tests covering various scenarios, including edge cases and error handling",
            "status": "pending"
          }
        ]
      },
      {
        "id": 39,
        "title": "Implement Real Linear API Calls for Task Updates",
        "description": "Replace the mock task update sync implementation with real Linear API calls to update issue title, description, and other fields when TaskMaster tasks are updated.",
        "details": "1. Update the LinearIntegration class to include real API calls:\n   - Modify handleTaskUpdated method to use linearClient.updateIssue() with the correct parameters\n   - Implement a function to map TaskMaster task fields to Linear issue fields\n\n2. Create a mapping function for task fields:\n   - Map title directly\n   - Map description, considering any formatting differences\n   - Map priority using the existing priority mapping logic\n   - Handle any custom fields or metadata as needed\n\n3. Implement the update logic:\n   - Fetch the current Linear issue using linearClient.issue(issueId)\n   - Compare TaskMaster task fields with Linear issue fields to determine what needs updating\n   - Construct an update object with only the changed fields\n   - Call linearClient.updateIssue(issueId, updateObject)\n\n4. Error handling and retry logic:\n   - Implement proper error handling for API failures\n   - Add retry logic with exponential backoff for transient errors\n   - Log detailed error information for debugging\n\n5. Implement success/failure messaging:\n   - Return appropriate success messages when updates are completed\n   - Provide clear error messages to the user in case of failures\n\n6. Performance optimization:\n   - Implement debouncing to avoid excessive API calls for rapid updates\n   - Consider batching updates if multiple tasks are being updated simultaneously\n\n7. Update the configuration:\n   - Add any necessary configuration options for controlling update behavior\n   - Implement functions to read and write these configuration options\n\n8. Maintain consistency with Linear:\n   - Implement a periodic sync to catch any updates made directly in Linear\n   - Handle conflict resolution if a task was updated in both systems\n\n9. Update related commands:\n   - Modify the 'task update' command to trigger the new real API update\n   - Update the 'sync' command to use the new update logic for existing tasks",
        "testStrategy": "1. Unit Tests:\n   - Test the mapping function with various task field combinations\n   - Mock Linear API responses and verify correct parameters are sent\n   - Test error handling and retry logic with simulated API failures\n   - Verify debouncing logic works as expected\n\n2. Integration Tests:\n   - Set up a Linear sandbox environment for testing\n   - Create test tasks in TaskMaster and verify they update correctly in Linear\n   - Test updating all possible fields: title, description, priority, etc.\n   - Verify that only changed fields are sent in update requests\n   - Test error scenarios by temporarily disabling API access\n\n3. End-to-End Tests:\n   - Perform a series of task updates in TaskMaster and verify they reflect in Linear\n   - Test the 'task update' command with various parameters\n   - Run the 'sync' command and verify it correctly updates existing tasks\n\n4. Performance Tests:\n   - Test with a large number of tasks to ensure efficient API usage\n   - Verify that debouncing prevents excessive API calls during rapid updates\n\n5. Conflict Resolution Tests:\n   - Update a task in both TaskMaster and Linear, then sync to test conflict resolution\n   - Verify that the periodic sync catches updates made directly in Linear\n\n6. Configuration Tests:\n   - Test that configuration changes affect the update behavior as expected\n\n7. Regression Tests:\n   - Ensure that existing functionality related to task creation and deletion still works\n   - Verify that the new implementation doesn't break any existing features",
        "status": "pending",
        "dependencies": [
          1,
          2,
          18,
          34,
          "6"
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-18T20:32:19.621Z",
      "updated": "2025-06-28T13:10:52.511Z",
      "description": "Tasks for master context"
    }
  }
}