/**
 * Mock Service Registry
 * 
 * Centralized registry for creating consistent mocks that implement
 * the required interfaces for testing.
 */

import { createInterfaceProxy, validateInterface, ILogger, IConfigManager, IHealthMonitor, ICircuitBreaker, IRecoveryManager, IErrorBoundary, IEventEmitter, ITimer, IFileSystem, IHttpClient } from '../../scripts/modules/core/interfaces.js';

// Helper to create jest mock functions with fallback
const createMockFn = (implementation = null) => {
    if (typeof jest !== 'undefined' && jest.fn) {
        return jest.fn(implementation);
    }
    // Fallback for when jest is not available
    const mockFn = function(...args) {
        mockFn.calls.push(args);
        if (mockFn.implementation) {
            return mockFn.implementation(...args);
        }
        return mockFn.returnValue;
    };
    mockFn.calls = [];
    mockFn.returnValue = undefined;
    mockFn.implementation = implementation;
    mockFn.mockImplementation = (fn) => {
        mockFn.implementation = fn;
        return mockFn;
    };
    mockFn.mockReturnValue = (value) => {
        mockFn.returnValue = value;
        return mockFn;
    };
    mockFn.mockResolvedValue = (value) => {
        mockFn.returnValue = Promise.resolve(value);
        return mockFn;
    };
    mockFn.mockRejectedValue = (value) => {
        mockFn.returnValue = Promise.reject(value);
        return mockFn;
    };
    mockFn.mockClear = () => {
        mockFn.calls = [];
        return mockFn;
    };
    mockFn.mockReset = () => {
        mockFn.calls = [];
        mockFn.returnValue = undefined;
        mockFn.implementation = null;
        return mockFn;
    };
    return mockFn;
};

/**
 * Mock Service Registry Class
 * Provides factory methods for creating consistent mocks
 */
export class MockServiceRegistry {
    constructor() {
        this.instances = new Map();
        this.defaultBehaviors = new Map();
    }

    /**
     * Create a mock logger
     * @param {Object} overrides - Override specific methods
     * @returns {Object} Mock logger implementation
     */
    static createLogger(overrides = {}) {
        const mockLogger = {
            log: createMockFn(),
            error: createMockFn(),
            warn: createMockFn(),
            info: createMockFn(),
            debug: createMockFn(),
            ...overrides
        };

        return createInterfaceProxy(mockLogger, ILogger, 'MockLogger');
    }

    /**
     * Create a mock config manager
     * @param {Object} overrides - Override specific methods
     * @param {Object} defaultConfig - Default configuration values
     * @returns {Object} Mock config manager implementation
     */
    static createConfigManager(overrides = {}, defaultConfig = {}) {
        const configs = new Map(Object.entries(defaultConfig));
        
        const mockConfigManager = {
            getLogLevel: jest.fn(() => 'info'),
            getGlobalConfig: jest.fn(() => ({})),
            getConfig: jest.fn((key) => configs.get(key)),
            setConfig: jest.fn((key, value) => configs.set(key, value)),
            hasConfig: jest.fn((key) => configs.has(key)),
            ...overrides
        };

        return createInterfaceProxy(mockConfigManager, IConfigManager, 'MockConfigManager');
    }

    /**
     * Create a mock health monitor
     * @param {Object} overrides - Override specific methods
     * @returns {Object} Mock health monitor implementation
     */
    static createHealthMonitor(overrides = {}) {
        const checks = new Map();
        let isStarted = false;
        let systemHealth = { status: 'healthy', checks: {} };

        const mockHealthMonitor = {
            registerCheck: jest.fn((name, checkFn, options) => {
                checks.set(name, { checkFn, options });
            }),
            start: jest.fn(() => {
                isStarted = true;
            }),
            stop: jest.fn(() => {
                isStarted = false;
            }),
            getSystemHealth: jest.fn(() => systemHealth),
            isHealthy: jest.fn(() => systemHealth.status === 'healthy'),
            reset: jest.fn(() => {
                checks.clear();
                isStarted = false;
                systemHealth = { status: 'healthy', checks: {} };
            }),
            // Test utilities
            _setSystemHealth: (health) => { systemHealth = health; },
            _getChecks: () => checks,
            _isStarted: () => isStarted,
            ...overrides
        };

        return createInterfaceProxy(mockHealthMonitor, IHealthMonitor, 'MockHealthMonitor');
    }

    /**
     * Create a mock circuit breaker registry
     * @param {Object} overrides - Override specific methods
     * @returns {Object} Mock circuit breaker implementation
     */
    static createCircuitBreaker(overrides = {}) {
        const breakers = new Map();
        
        const createBreaker = (name) => ({
            getStatus: jest.fn(() => ({ state: 'closed', failures: 0, successes: 0 })),
            reset: createMockFn(),
            execute: jest.fn(async (fn) => await fn()),
            recordSuccess: createMockFn(),
            recordFailure: createMockFn()
        });

        const mockCircuitBreaker = {
            getBreaker: jest.fn((name) => {
                if (!breakers.has(name)) {
                    breakers.set(name, createBreaker(name));
                }
                return breakers.get(name);
            }),
            createBreaker: jest.fn((name, options) => {
                const breaker = createBreaker(name);
                breakers.set(name, breaker);
                return breaker;
            }),
            getAllStatuses: jest.fn(() => {
                const statuses = {};
                for (const [name, breaker] of breakers.entries()) {
                    statuses[name] = breaker.getStatus();
                }
                return statuses;
            }),
            resetAll: jest.fn(() => {
                for (const breaker of breakers.values()) {
                    breaker.reset();
                }
            }),
            reset: jest.fn((name) => {
                if (breakers.has(name)) {
                    breakers.get(name).reset();
                }
            }),
            // Test utilities
            _getBreakers: () => breakers,
            _clearAll: () => breakers.clear(),
            ...overrides
        };

        return createInterfaceProxy(mockCircuitBreaker, ICircuitBreaker, 'MockCircuitBreaker');
    }

    /**
     * Create a mock recovery manager
     * @param {Object} overrides - Override specific methods
     * @returns {Object} Mock recovery manager implementation
     */
    static createRecoveryManager(overrides = {}) {
        const strategies = new Map();
        const history = [];
        let isStarted = false;

        const mockRecoveryManager = {
            executeWithRecovery: jest.fn(async (fn, retries = 3) => {
                try {
                    return await fn();
                } catch (error) {
                    if (retries > 0) {
                        return await mockRecoveryManager.executeWithRecovery(fn, retries - 1);
                    }
                    throw error;
                }
            }),
            addRecoveryStrategy: jest.fn((name, strategy) => {
                strategies.set(name, strategy);
            }),
            setDefaultStrategy: jest.fn((strategy) => {
                strategies.set('default', strategy);
            }),
            getRecoveryHistory: jest.fn(() => [...history]),
            reset: jest.fn(() => {
                strategies.clear();
                history.length = 0;
                isStarted = false;
            }),
            start: jest.fn(() => {
                isStarted = true;
            }),
            registerStrategy: jest.fn((name, strategy) => {
                strategies.set(name, strategy);
            }),
            // Test utilities
            _getStrategies: () => strategies,
            _addToHistory: (entry) => history.push(entry),
            _isStarted: () => isStarted,
            ...overrides
        };

        return createInterfaceProxy(mockRecoveryManager, IRecoveryManager, 'MockRecoveryManager');
    }

    /**
     * Create a mock error boundary registry
     * @param {Object} overrides - Override specific methods
     * @returns {Object} Mock error boundary implementation
     */
    static createErrorBoundary(overrides = {}) {
        const boundaries = new Map();
        const errors = [];

        const createBoundary = (name, config) => ({
            execute: jest.fn(async (fn, args, options) => {
                try {
                    return await fn(...args);
                } catch (error) {
                    errors.push({ name, error, timestamp: Date.now() });
                    if (options && options.fallback) {
                        return await options.fallback();
                    }
                    throw error;
                }
            }),
            handleError: jest.fn((error, context) => {
                errors.push({ name, error, context, timestamp: Date.now() });
            }),
            reset: jest.fn(() => {
                // Reset boundary state
            }),
            on: createMockFn(),
            off: createMockFn(),
            getStatus: jest.fn(() => ({
                name,
                errors: errors.filter(e => e.name === name).length,
                isolated: false
            }))
        });

        const mockErrorBoundary = {
            register: jest.fn((name, config) => {
                const boundary = createBoundary(name, config);
                boundaries.set(name, boundary);
                return boundary;
            }),
            getBoundary: jest.fn((name, config) => {
                if (!boundaries.has(name)) {
                    boundaries.set(name, createBoundary(name, config));
                }
                return boundaries.get(name);
            }),
            handleError: jest.fn((error, context) => {
                errors.push({ error, context, timestamp: Date.now() });
            }),
            getErrorHistory: jest.fn(() => [...errors]),
            reset: jest.fn(() => {
                boundaries.clear();
                errors.length = 0;
            }),
            clearErrors: jest.fn(() => {
                errors.length = 0;
            }),
            getAllStatuses: jest.fn(() => {
                const statuses = {};
                for (const [name, boundary] of boundaries.entries()) {
                    statuses[name] = boundary.getStatus();
                }
                return statuses;
            }),
            // Test utilities
            _getBoundaries: () => boundaries,
            _getErrors: () => errors,
            ...overrides
        };

        return createInterfaceProxy(mockErrorBoundary, IErrorBoundary, 'MockErrorBoundary');
    }

    /**
     * Create a mock event emitter
     * @param {Object} overrides - Override specific methods
     * @returns {Object} Mock event emitter implementation
     */
    static createEventEmitter(overrides = {}) {
        const listeners = new Map();

        const mockEventEmitter = {
            emit: jest.fn((event, ...args) => {
                if (listeners.has(event)) {
                    for (const listener of listeners.get(event)) {
                        listener(...args);
                    }
                }
                return true;
            }),
            on: jest.fn((event, listener) => {
                if (!listeners.has(event)) {
                    listeners.set(event, []);
                }
                listeners.get(event).push(listener);
            }),
            off: jest.fn((event, listener) => {
                if (listeners.has(event)) {
                    const eventListeners = listeners.get(event);
                    const index = eventListeners.indexOf(listener);
                    if (index > -1) {
                        eventListeners.splice(index, 1);
                    }
                }
            }),
            once: jest.fn((event, listener) => {
                const onceListener = (...args) => {
                    listener(...args);
                    mockEventEmitter.off(event, onceListener);
                };
                mockEventEmitter.on(event, onceListener);
            }),
            removeAllListeners: jest.fn((event) => {
                if (event) {
                    listeners.delete(event);
                } else {
                    listeners.clear();
                }
            }),
            listenerCount: jest.fn((event) => {
                return listeners.has(event) ? listeners.get(event).length : 0;
            }),
            // Test utilities
            _getListeners: () => listeners,
            ...overrides
        };

        return createInterfaceProxy(mockEventEmitter, IEventEmitter, 'MockEventEmitter');
    }

    /**
     * Create a mock timer
     * @param {Object} overrides - Override specific methods
     * @returns {Object} Mock timer implementation
     */
    static createTimer(overrides = {}) {
        const timers = new Map();
        let currentTime = Date.now();

        const mockTimer = {
            setTimeout: jest.fn((fn, delay) => {
                const id = Math.random();
                timers.set(id, { fn, delay, type: 'timeout' });
                return id;
            }),
            setInterval: jest.fn((fn, interval) => {
                const id = Math.random();
                timers.set(id, { fn, interval, type: 'interval' });
                return id;
            }),
            clearTimeout: jest.fn((id) => {
                timers.delete(id);
            }),
            clearInterval: jest.fn((id) => {
                timers.delete(id);
            }),
            now: jest.fn(() => currentTime),
            // Test utilities
            _getTimers: () => timers,
            _setCurrentTime: (time) => { currentTime = time; },
            _advanceTime: (ms) => { currentTime += ms; },
            _triggerTimer: (id) => {
                if (timers.has(id)) {
                    const timer = timers.get(id);
                    timer.fn();
                    if (timer.type === 'timeout') {
                        timers.delete(id);
                    }
                }
            },
            _triggerAllTimers: () => {
                for (const [id, timer] of timers.entries()) {
                    timer.fn();
                    if (timer.type === 'timeout') {
                        timers.delete(id);
                    }
                }
            },
            ...overrides
        };

        return createInterfaceProxy(mockTimer, ITimer, 'MockTimer');
    }

    /**
     * Create a mock file system
     * @param {Object} overrides - Override specific methods
     * @param {Object} files - Initial file structure
     * @returns {Object} Mock file system implementation
     */
    static createFileSystem(overrides = {}, files = {}) {
        const fileSystem = new Map(Object.entries(files));

        const mockFileSystem = {
            readFile: jest.fn(async (filePath, encoding = 'utf8') => {
                if (fileSystem.has(filePath)) {
                    return fileSystem.get(filePath);
                }
                throw new Error(`ENOENT: no such file or directory, open '${filePath}'`);
            }),
            writeFile: jest.fn(async (filePath, data, encoding = 'utf8') => {
                fileSystem.set(filePath, data);
            }),
            existsSync: jest.fn((filePath) => {
                return fileSystem.has(filePath);
            }),
            mkdir: jest.fn(async (dirPath, options = { recursive: true }) => {
                // Simulate directory creation
                fileSystem.set(dirPath, null);
            }),
            readdir: jest.fn(async (dirPath) => {
                const files = [];
                for (const path of fileSystem.keys()) {
                    if (path.startsWith(dirPath + '/')) {
                        const relativePath = path.substring(dirPath.length + 1);
                        if (!relativePath.includes('/')) {
                            files.push(relativePath);
                        }
                    }
                }
                return files;
            }),
            stat: jest.fn(async (filePath) => {
                if (!fileSystem.has(filePath)) {
                    throw new Error(`ENOENT: no such file or directory, stat '${filePath}'`);
                }
                return {
                    isFile: () => fileSystem.get(filePath) !== null,
                    isDirectory: () => fileSystem.get(filePath) === null,
                    size: fileSystem.get(filePath)?.length || 0,
                    mtime: new Date()
                };
            }),
            // Test utilities
            _getFiles: () => fileSystem,
            _setFile: (path, content) => fileSystem.set(path, content),
            _clear: () => fileSystem.clear(),
            ...overrides
        };

        return createInterfaceProxy(mockFileSystem, IFileSystem, 'MockFileSystem');
    }

    /**
     * Create a mock HTTP client
     * @param {Object} overrides - Override specific methods
     * @param {Object} responses - Predefined responses
     * @returns {Object} Mock HTTP client implementation
     */
    static createHttpClient(overrides = {}, responses = {}) {
        const createResponse = (data, status = 200) => ({
            ok: status >= 200 && status < 300,
            status,
            statusText: status === 200 ? 'OK' : 'Error',
            json: jest.fn(async () => data),
            text: jest.fn(async () => JSON.stringify(data)),
            headers: new Map()
        });

        const mockHttpClient = {
            get: jest.fn(async (url, options = {}) => {
                if (responses[url]) {
                    return createResponse(responses[url]);
                }
                return createResponse({ message: 'Not found' }, 404);
            }),
            post: jest.fn(async (url, data, options = {}) => {
                if (responses[url]) {
                    return createResponse(responses[url]);
                }
                return createResponse({ message: 'Created', data }, 201);
            }),
            put: jest.fn(async (url, data, options = {}) => {
                if (responses[url]) {
                    return createResponse(responses[url]);
                }
                return createResponse({ message: 'Updated', data });
            }),
            delete: jest.fn(async (url, options = {}) => {
                if (responses[url]) {
                    return createResponse(responses[url]);
                }
                return createResponse({ message: 'Deleted' });
            }),
            request: jest.fn(async (url, options = {}) => {
                const method = options.method || 'GET';
                switch (method.toUpperCase()) {
                    case 'GET':
                        return mockHttpClient.get(url, options);
                    case 'POST':
                        return mockHttpClient.post(url, options.body, options);
                    case 'PUT':
                        return mockHttpClient.put(url, options.body, options);
                    case 'DELETE':
                        return mockHttpClient.delete(url, options);
                    default:
                        return createResponse({ message: 'Method not allowed' }, 405);
                }
            }),
            // Test utilities
            _setResponse: (url, response) => { responses[url] = response; },
            _getResponses: () => responses,
            _clearResponses: () => Object.keys(responses).forEach(key => delete responses[key]),
            ...overrides
        };

        return createInterfaceProxy(mockHttpClient, IHttpClient, 'MockHttpClient');
    }

    /**
     * Create a complete dependency set with all mocks
     * @param {Object} overrides - Override specific services
     * @returns {Object} Complete dependency set
     */
    static createCompleteDependencySet(overrides = {}) {
        return {
            logger: MockServiceRegistry.createLogger(overrides.logger),
            configManager: MockServiceRegistry.createConfigManager(overrides.configManager),
            healthMonitor: MockServiceRegistry.createHealthMonitor(overrides.healthMonitor),
            circuitBreakerRegistry: MockServiceRegistry.createCircuitBreaker(overrides.circuitBreakerRegistry),
            recoveryManager: MockServiceRegistry.createRecoveryManager(overrides.recoveryManager),
            errorBoundaryRegistry: MockServiceRegistry.createErrorBoundary(overrides.errorBoundaryRegistry),
            eventEmitter: MockServiceRegistry.createEventEmitter(overrides.eventEmitter),
            timer: MockServiceRegistry.createTimer(overrides.timer),
            fileSystem: MockServiceRegistry.createFileSystem(overrides.fileSystem),
            httpClient: MockServiceRegistry.createHttpClient(overrides.httpClient),
            ...overrides
        };
    }

    /**
     * Reset all mock functions in a dependency set
     * @param {Object} dependencies - Dependency set to reset
     */
    static resetMocks(dependencies) {
        for (const [name, service] of Object.entries(dependencies)) {
            if (service && typeof service === 'object') {
                // Reset jest mocks
                for (const method of Object.values(service)) {
                    if (jest.isMockFunction(method)) {
                        method.mockReset();
                    }
                }
                
                // Call reset method if available
                if (typeof service.reset === 'function') {
                    service.reset();
                }
            }
        }
    }

    /**
     * Clear all mock call history in a dependency set
     * @param {Object} dependencies - Dependency set to clear
     */
    static clearMocks(dependencies) {
        for (const [name, service] of Object.entries(dependencies)) {
            if (service && typeof service === 'object') {
                for (const method of Object.values(service)) {
                    if (jest.isMockFunction(method)) {
                        method.mockClear();
                    }
                }
            }
        }
    }
}